= The Myth's Book - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/se-edu/addressbook-level4/tree/master

By: `Team The Myth`      Since: `Jun 2016`      Licence: `MIT`

== Introduction

The Myth's Book is an address book dedicated for university students to store useful information such
as websites, phone numbers and emails of the people around them for personal usage. The application helps students
to keep track of birthday dates and upcoming events through a calendar and facilitate convenient access to their friend's website
and even Google Maps location through the in-built browser panel in the application. Furthermore, there are many
useful tools such as finding group tags (e.g. friends, neighbours) and switching themes for better user preference and usability.

The Myth's Book is a `Command Line Input` based software which helps caters to students who are efficient and comfortable
in typing out command line inputs to manipulate with information of their contacts in the address book.
The Myth's Book is a software application that is coded in `Java` programming language.

== About

This developer guide will teach you how to set up the application software on IntelliJ IDEA and
allow you to understand the process, features and structure of the application software to help
you become a more knowledgeable contributor towards debugging, updating and improving The Myth's Book.

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

link:#the-myths-book---developer-guide[Back To Top]

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 2.1.1 : Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 2.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 2.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 2.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagram.png[width="800"]
_Figure 2.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 2.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 2.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 2.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 2.3.1 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagram.png[width="800"]
_Figure 2.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagram.png[width="800"]
_Figure 2.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

link:#the-myths-book---developer-guide[Back To Top]

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +
**Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()` +
**Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** Hard for new developers to understand the template pattern. +
**Alternative 2:** Just override `execute()` +
**Pros:** Does not involve the template pattern, easier for new developers to understand. +
**Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +
**Alternative 1 (current choice):** Saves the entire address book. +
**Pros:** Easy to implement. +
**Cons:** May have performance issues in terms of memory usage. +
**Alternative 2:** Individual command knows how to undo/redo by itself. +
**Pros:** Will use less memory (e.g. for `delete`, just save the person being deleted). +
**Cons:** We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +
**Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +
**Alternative 2:** Include all commands. +
**Pros:** Might be more intuitive for the user. +
**Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +
**Alternative 1 (current choice):** Use separate stack for undo and redo +
**Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +
**Alternative 2:** Use `HistoryManager` for undo/redo +
**Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]

=== Add Event mechanism
// tag::addevent[]
Add event mechanism adds an event which stores in the The Myth's Book,
which will then be used in a Calendar in future implementation. A reminder feature will also be tagged on to the event.

The add event mechanism is facilitated by a `EventList`, which is stored in The Myth's Book. Similar to the PersonList and TagList, the list contains the
different events with their information given by the user. This command inherits from `UndoableCommand`.

From Figure 5.2.1 below, it is visible that `AddEventCommand` inherits from `UndoableCommand` which is an extra layer between abstract `Command` class in which the SortCommand
can be undoable, where the previous state of the address book before sorting is saved.

image::AddEventCommandLogicClassDiagram.PNG[width="800"]
Figure 5.2.1 AddEventCommand Logic Class Diagram

Code of `AddEventCommand`:

----
public class AddEventCommand extends UndoableCommand {

@Override
 public CommandResult executeUndoableCommand() throws CommandException {
    requireNonNull(model);
     try {
         model.addEvent(toAdd);
         return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateEventException e) {
        throw new CommandException(MESSAGE_DUPLICATE_EVENT);
        }
    }
}
----

A UniqueEventList is also created to store the list of Events in AddressBook.java

Code of `UniqueEventList.java` when an Event is created and stored into the UniqueEventList:

The new Events will be stored in UniqueEventList in AddressBook.
----
public class UniqueEventList implements Iterable<Event> {

    private final ObservableList<Event> internalList = FXCollections.observableArrayList();
    ...
    public void add(ReadOnlyEvent toAdd) throws DuplicateEventException {
        requireNonNull(toAdd);
        if (contains(toAdd)) {
            throw new DuplicateEventException();
        }
        internalList.add(new Event(toAdd));
    }
    ...
}
----

==== Design Consideration
**Aspect:** Implementation of `AddEventCommand` +
**Alternative 1 (current choice):** Extends to UndoableCommand +
**Pros:** Developer can undo their command when they do not want to add the event. +
**Cons:** Developer has to understand the implementation of UndoableCommand +

---
**Aspect:** How does add event executes +
**Alternative 1 (current choice):** Take in Name(person) , Date(event) and Address(person) +
**Pros:** Simple to implement as add event uses the current Name for the Person as the Name of event and Address of the event due to similar CliSyntax. +
**Cons:** Developer might get confused with the different use of imports as Name and Address are from person while Date is from events. +
// end::addevent[]

// tag::switch[]
=== Switch Theme mechanism

The switch theme mechanism is facilitated by a `ThemesList`, which resides inside `AddressBook`. `ThemesList` contains a list of CSS files, in which each file are of differing colour themes for the application user interface. It sets the theme of the application to the theme specified by the index given by the user. This command will inherit from `Command`.

image::SwitchThemeCommandDiagram1.png[width="800"]

As seen from the diagram above, `SwitchThemeCommand` inherits `Command`, which means its state is not saved by the address book, and it cannot be undone after executing the command.

Suppose that the user has just launched the application. The `ThemesList` will be initialised based on the current existing colour themes.

The user executes `themeslist` to look through the existing colour themes, and pick one that he or she wants.

The user will then execute `switch 2`, with `2` being the `index` of the theme that the user prefers, provided by the executed `themeslist`.

The `ThemesList` will take the `index` provided by the user, and return a `String` of the CSS file name based on the `index`.

The execution of `switch 2` toggles an event `ChangeThemeRequestEvent`, which will then be listened and handled by `MainWindow`.

The `Stylesheets` of the `MainWindow` will then remove the current existing CSS file, which is the current theme, and add the given `String` of the CSS file into `Stylesheets`. That will set the current colour theme of `The Myth's Book` to the preferred colour theme.

Code of SwitchThemeCommand :
[source, java]
----
public class SwitchThemeCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... switch theme logic ...
        EventsCenter.getInstance().post(new ChangeThemeRequestEvent(themeToChange));
    }
}
----

Listener for ChangeThemeRequestEvent in MainWindow.java :
[source,java]
----
@Subscribe
private void handleChangeThemeEvent(ChangeThemeRequestEvent event) {
    logger.info(LogsCenter.getEventHandlingLogMessage(event));
    handleChangeTheme(event.theme);
}
----

Removing and adding of CSS file into Stylesheets in MainWindow.java :
[source, java]
----
public void handleChangeTheme(String theme) {
    if (getRoot().getStylesheets().size() > 1) {
        getRoot().getStylesheets().remove(CURRENT_THEME_INDEX);
    }
    getRoot().getStylesheets().add("/view/" + theme);
}
----

The following sequence diagram shows how the switch theme operation works:

image::SwitchThemeCommandDiagram2.png[width="800"]

As seen from the diagram above, when `switch 1` is typed into the command line input, a new `SwitchThemeCommand` is created.

image::SwitchThemeCommandDiagram3.png[width="800"]

As seen from the diagram above, when `switch 1` is executed in `SwitchThemeCommand`, it will post `ChangeThemeRequestEvent` to the `EventsCenter`.

Upon detecting `ChangeThemeRequestEvent`, `Ui` will call `handleChangeTheme` to handle the event, update the `MainWindow` accordingly and update its status bar.

==== Design Considerations

**Aspect:** Implementation of `SwitchThemeCommand` +
**Alternative 1 (current choice):** Extending to `Command` class. +
**Pros:** Developers do not need to learn the implementation of `UndoableCommand` class. +
**Cons:** `SwitchThemeCommand` cannot be undone and have to repeatedly call command to switch to different themes. +
**Alternative 2:** Extending to `UndoableCommand` class. +
**Pros:** Might be more favourable to users to undo `SwitchThemeCommand` if he/she switch to an incorrect theme. +
**Cons:** Developers need to learn the implementation of `UndoableCommand`. Difficult to implement. +

---

**Aspect:** How switch theme executes +
**Alternative 1 (current choice):** Taking in index (type Integer) as the argument. +
**Pros:** Simple to implement since the index will tally with `ThemesList`. Simple to use since users don't have to remember the names and look at the index in `ThemesList`. +
**Cons:** Maybe less favourable for users when the size of `ThemesList` increase. +
**Alternative 2:** Taking in theme's name (type String) as the argument. +
**Pros:** Might be more favourable for long-time users since names may be easier to remember than numbers after using the application for a long time. +
**Cons:** Harder to implement and test. +
// end::switch[]

// tag::sort[]
=== Sort mechanism

The sort mechanism sorts the names of people inside the `addressbook` of the 'ModelManager'.
When the sort method is executed, it organizes the position of the people existing in the `addressbook`
based on their names in alphabetical order. The sort mechanism touches all components of the software application
but mainly involving the logic and model component.

In the figure [Figure 5.2.1] below, the `SortCommand` inherits from `UndoableCommand`
which is an extra layer between abstract `Command` class which belongs to the Logic Component.
This allows the SortCommand to be undoable, where the previous state of the address book before sorting is saved.

image::SortCommandLogicClassDiagram.PNG[width="800"]
Figure 5.2.1 SortCommand Logic Class Diagram

Suppose a user has an unorganized list of contacts and executes the `SortCommand` to organize his contacts.

The execution of SortCommand is processed in this way:

. User will execute and create a new `SortCommand` so as to sort the address book.
. When `executeUndoableCommand()` of `SortCommand` is called, `model.sort()` in the method will be processed.
. The `internalList` of the address book is then accessed and sorted through a `lambda` function which
  compares the name of everyone and necessarily switches the position between contacts throughout the `internalList` by comparing names between person r1 and r2 sequentially.
. After `internalList` is sorted, function `updateFilterPersonList(PREDICATE_SHOW_ALL_PERSONS)` is called
  to update the list being filtered and also call an event `indicatedAddressBookChanged()`
  to update the `PersonListPanel` of the GUI being shown.

Code of `SortCommand.java` and its method `executeUndoableCommand`:
[source,java]
----
public class SortCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        model.sort();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
----

Code of sort method inside `ModelManager.java`:
[source,java]
----
@Override
public synchronized void sort() {
    addressBook.sort();
    updateFilteredPersonList(PREDICATE_SHOW_ALL_PERSONS);
    indicateAddressBookChanged();
}
----

Code of sort method inside `UniquePersonList.java` using a lambda function to sort `internalList`:
[source,java]
----
public void sort() {
    internalList.sort((r1, r2) -> (
            r1.getName().toString().compareTo(r2.getName().toString())));
}

----
The following sequence diagram shows how the sort operation works:
As seen from the figure [Figure 5.2.2] below, when sort is typed into command line input, new `SortCommand` is created.

image::SortCommandLogicSequenceDiagram.PNG[width="800"]
Figure 5.2.2 SortCommand Logic Sequence Diagram

When `executeUndoableCommand` is called in SortCommand class, it will call the sort function in ModelManager.
It will call the sort() function of its own class until it reaches InternalList.sort() where the sorting of
contacts positions based on their names will be executed.
Ultimately, achieving the final product of having a sorted addressbook being shown in the `PersonListPanel`

image::SortCommandModelSequenceDiagram.PNG[width="800"]
Figure 5.2.3 SortCommand Model Sequence Diagram

==== Design Considerations
**Aspect:** Implementation of `SortCommand` +
**Alternative 1 (current choice):** extending to `UndoableCommand` class +
**Pros:** Sort method call is able to be undone if needed as it now inherits from the Super Class. +
**Cons:** Developers might need to understand how `UndoableCommand` works before implementation. +
**Alternative 2:** Just extend to `Command` class +
**Pros:** Does not need understanding of `UndoableCommand` class. +
**Cons:** Unable to undo sort method and work from previous state of address book if user has called `SortCommand` to sort address book.

---
**Aspect:** Implementation of how sort executes +
**Alternative 1 (current choice):** Compare and sort the names of every individual alphabetically. +
**Pros:** Easy to implement and uses less complexity. +
**Cons:** Unable to sort based on user preferences like email, phone number. +
**Alternative 2:** Include all types of sorting like sorting phone numbers and emails. +
**Pros:** Might be more favourable for user who have specific needs to collate certain information such as
 email or phone number about his contacts in an alphanumeric order. +
**Cons:** Difficult to implement and wastes memory space as sorting might be unnecessary and complex for general users
          since main goal is to keep address book organized. +

---
//end::sort[]

// tag::access[]
=== Access Website mechanism

The access website mechanism has an `AccessCommand` that allows user to access the website by stating the
index of the desired contact in the contact list viewed.
The implementation of the access website mechanism is mostly done in the `UI`, `Model`, and `Logic` component.
The `AccessCommand` class inherits from the `Command` class.

Suppose a user would like to access one of his contacts website that is listed in the `PersonListPanel` of the address book
and executes the `AccessCommand` to access the website.

The execution of AccessCommand is processed in this way:

. User will input `access index` where `index` refers to the index of the person listed in the `PersonListPanel` in GUI.
. Input of user will be parse as an argument through the AddressBookParser and AccessCommandParser to extract the index.
. A new `AccessCommand` with the index inputted will be created.
. The method `execute()` of the `AccessCommand` will then be processed,
 where the person of the website that the user wants to access will be obtained through the
 index of the `lastShownList` and stored into `person` variable which is of `ReadOnlyPerson` data-type.
. The `EventsCenter` will then post a new `AccessWebsiteRequestEvent` with parameter input of the `website` of the `person` variable.
. The `AccessWebsiteRequestEvent` event would then be handled by an event handler `handleAccessWebsiteEvent` in `BrowserPanel`.
. The event handler will help to load the website of the person through the browser panel based on the website inputted.

Code of `AccessCommand` and its method `execute()`:
[source,java]
----
public class AccessCommand extends Command {
    private final Index targetIndex;

    public AccessCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
        }

        ReadOnlyPerson person = lastShownList.get(targetIndex.getZeroBased());

        EventsCenter.getInstance().post(new AccessWebsiteRequestEvent(person.getWebsite().toString()));
        return new CommandResult(String.format(MESSAGE_ACCESS_PERSON_SUCCESS, targetIndex.getOneBased()));
    }
}
----

Code of how accessing website event is handled in `BrowserPanel`:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {
    public void handleWebsiteAccess(String website) {
        browserPanel.loadPage(website);
    }

    public void loadPage(String url) {
            Platform.runLater(() -> browser.getEngine().load(url));
        }

    @Subscribe
    private void handleAccessWebsiteEvent(AccessWebsiteRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        handleWebsiteAccess(event.website);
    }
}
----

Through the sequence diagram, you can see how the code executes when a user
inputs `access 1` into the command line.

Sequence diagram for `Logic` Component for `AccessCommand` and how it is executed:

image::AccessCommandLogicSequenceDiagram.PNG[width="800"]
Figure 5.6.1 Access Command Logic Sequence Diagram

After creating a new `AccessCommand`, `LogicManager` will call execute on `AccessCommand`
and this will result in the website of the person at the index inputted to be called through an event request and event handler.
The website will then be loaded onto the browser of the `BrowserPanel` of the `MainWindow`.

Sequence diagram for `execute()` method of `AccessCommand` and its event handling:

image::AccessCommandEventsSequenceDiagram.PNG[width="800"]
Figure 5.6.2 Access Command Model/EventsCenter/UI Sequence Diagram

==== Design Considerations
**Aspect:** How accessing a website of a person executes +
**Alternative 1 (current choice):** Create a new event request and event handler for AccessCommand. +
**Pros:** Able to have more features like AccessWebsite and Select feature that is able to exist concurrently in the application. +
**Cons:** Having the current select feature which is to search for names of contact of Google is quite unnecessary. +
**Alternative 2:** Change the code of event request and event handler related to SelectCommand to allow users to access website of their contacts instead
of creating a search on contacts name through the browser panel. +
**Pros:** Select feature which seems unnecessary is replaced with a more useful feature of AccessWebsite. +
**Cons:** Will not be able to replace the select feature anymore which might be important for other aspects such as creating a Person Card Viewer
which is important for GUI enhancement. +

//end::access[]

// tag::locate[]
=== Location mechanism
The location mechanism has an `LocationCommand` that allows user to access the address through Google Maps Search
by stating the index of the desired contact in the contact list viewed.
The implementation of the location mechanism is mostly done in the `UI`, `Model`, and `Logic` component
and is very similar to the access website mechanism in terms of implementation and sequential process.
The `LocationCommand` class inherits from the `Command` class.

Suppose a user would like to access one of his contacts address that is listed in the `PersonListPanel` of the address book
and executes the `LocationCommand` to access the location using the address attained.

The execution of LocationCommand is processed in this way:

. User will input `locate index` where `index` refers to the index of the person listed in the `PersonListPanel` in GUI.
. Input of user will be parse as an argument through the AddressBookParser and LocationCommandParser to extract the index.
. A new `LocationCommand` with the index inputted will be created.
. The method `execute()` of the `LocationCommand` will then be processed,
 where the person of the address that the user wants to find on Google Maps Search will be obtained through the
 index of the `lastShownList` and stored into `person` variable which is of `ReadOnlyPerson` data-type.
. The `EventsCenter` will then post a new `AccessLocationRequestEvent` with parameter input of the `address` of the `person` variable.
. The `AccessLocationRequestEvent` event would then be handled by an event handler `handleAccessLocationEvent` in `BrowserPanel`.
. The event handler will help to load the address of the person through Google Maps Search in the browser panel.

Code of `LocationCommand` and its method `execute()`:
[source,java]
----
public class LocationCommand extends Command {
    private final Index targetIndex;

    public LocationCommand(Index targetIndex) {
            this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
        }

        ReadOnlyPerson person = lastShownList.get(targetIndex.getZeroBased());
        EventsCenter.getInstance().post(new AccessLocationRequestEvent(person.getAddress().toString()));
        return new CommandResult(String.format(MESSAGE_LOCATE_PERSON_SUCCESS, targetIndex.getOneBased()));
    }
}
----

Code of how accessing location event is handled in `BrowserPanel`:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {
    public static final String GOOGLE_SEARCH_URL_PREFIX = "https://www.google.com.sg/maps?safe=off&q=";
    public static final String GOOGLE_SEARCH_URL_SUFFIX = "&cad=h";

    private void loadPersonLocation(String location) {
        loadPage(GOOGLE_SEARCH_URL_PREFIX + location.replaceAll(" ", "+")
                + GOOGLE_SEARCH_URL_SUFFIX);
    }

    public void loadPage(String url) {
            Platform.runLater(() -> browser.getEngine().load(url));
    }

    @Subscribe
    private void handleAccessLocationEvent(AccessLocationRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        loadPersonLocation(event.location);
    }
}
----

Through the sequence diagram, you can see how the code executes when a user
inputs `locate 1` into the command line.

Sequence diagram for `Logic` Component for `LocationCommand` and how it is executed:

image::LocationCommandLogicSequenceDiagram.png[width="800"]
Figure 5.7.1 Location Command Logic Sequence Diagram

After creating a new `LocationCommand`, `LogicManager` will call execute on `LocationCommand`
and this will result in the address of the person at the index inputted to be called through an event request and event handler.
The address will then be loaded onto Google Maps Search of the browser of the `MainWindow`.

Sequence diagram for `execute()` method of `LocationCommand` and its event handling:

image::LocationCommandEventsSequenceDiagram.png[width="800"]
Figure 5.7.2 Access Command Model/EventsCenter/UI Sequence Diagram

==== Design Considerations
**Aspect:** How accessing a location of a person executes +
**Alternative 1 (current choice):** Create a new event request and event handler for LocationCommand. +
**Pros:** Able to have more features like Location, AccessWebsite and Select feature that is able to exist concurrently in the application. +
**Cons:** Having the current select feature which is to search for names of contact of Google is quite unnecessary. +
**Alternative 2:** Change the code of event request and event handler related to SelectCommand to allow users to access the address through Google Maps Search instead
of processing a search on contact's name through the google search using browser. +
**Pros:** Select feature which seems unnecessary is replaced with a more useful feature of AccessWebsite. +
**Cons:** Will not be able to replace the select feature anymore which might be important for other aspects such as creating a PersonCard Viewer
which is important for GUI enhancement. +

//end::locate[]

// tag::find[]
=== Find mechanism
The find mechanism is facilitated by the `NameContainsKeyWordsPredicate` class which resides in the person class. It supports finding any person in the address book using their full name or a part of the name.

However, if a user is searching by part of a name, the substring must be in the beginning of the first name or last name and it has to be at least two characters long.

The `find` command is not an undoable command and therefore it inherits from `Command` rather than `UndoableCommand`.

The `NameContainsKeyWordsPredicate` class has a test function that uses stream, a new feature of Java 8 to process data more efficiently than using loops. The `test()` returns true if either the full name(first name + last name) ignoring case or it contains a substring of the name ignoring case.

The main logic in the `NameContainsKeyWordsPredicate` class comes from the `StringUtil` class that acts as a helper function for handling any operations related to strings.

How the `containsPartofWord()` function works:
[source,java]
----
public static boolean containsPartOfWord(String sentence, String word) {
    requireNonNull(sentence);
    requireNonNull(word);
    ...
}
----

The function takes in two string arguments, one being the name of the person and the other being the substring. The function first checks to see if either of these arguments are null using java.util.Objects.requireNonNull. If any of the arguments are null, it throws a NullPointerException.
[source,java]
----
public static boolean containsPartOfWord(String sentence, String word) {
    ....
    checkArgument(preppedWord.split("\\s+").length == 1, "Word parameter should be a single word");
    String preppedSentence = sentence;
    String[] wordsInPreppedSentence = preppedSentence.split("\\s+");
    ...
}
----

If both strings are valid, it then checks that the substring is only one word. The function then splits up the person’s name into first name and last name.
[source,java]
----
public static boolean containsPartOfWord(String sentence, String word) {
    ....
    if (preppedWord.length() >= 2) {
        for (String wordInSentence : wordsInPreppedSentence) {
            if ((wordInSentence.toLowerCase().contains(preppedWord.toLowerCase()))
                && (wordInSentence.toLowerCase().startsWith(preppedWord.toLowerCase()))) {
            return true;
            }
        }
    ....
----
The function first checks if the length of the substring is greater than, equal to 2. Using an enhanced for loop, the function iterates through the words in a person’s name and checks to see if any of them start with the substring ignoring cases.

If yes, then the function returns true else it returns false.

==== Design Considerations
**Aspect:** Implementation of `containsPartOfWord` +
**Alternative 1 (current choice):** length>=2 +
**Pros:** Making sure that not every person's name comes up in find. For e.g: 'find a' +
**Cons:** There might exist people whose first or last name is stored as a single character +
**Alternative 2:** Allow any length of substrings +
**Pros:** No exception cases +
**Cons:** No purpose of using find as if you search for one character, all contacts might get filtered +
// end::find[]

//tag::birthday[]
=== Birthdays mechanism
The Birthdays mechanism is facilitated by the `CheckIfBirthday` class which resides in the person class. It lists out all contacts that have their birthdays today.

The `Birthdays` command is an undoable command and thus inherits from `UndoableCommand` rather than `Command`.

The `CheckIfBirthday` class checks if the birth month and day of a contact matches today. As the birthday field is a birthday object, it is converted to a string using the `toString()` method in the `Birthday` class and then parsed into a date object using `simpleDateFormat()`.
[source,java]
----
 Date date = new SimpleDateFormat("dd/MM/yyyy").parse(birthday);
----

The date is then converted into a `Calendar` object for easier comparison. Then the Day and Month of today is compared with the day and month of a person's birthday in the following way.
[source,java]
----
return (((cal.get(Calendar.MONTH)) == Calendar.getInstance().get(Calendar.MONTH))
                && ((cal.get(Calendar.DAY_OF_MONTH) == Calendar.getInstance().get(Calendar.DAY_OF_MONTH))));
    }
----

An overall view of birthdays command logic is shown in Figure 5.8.1

image::BirthdaysMechanism.png[width="800"]
Figure 5.8.1 Birthdays Command Logic Sequence Diagram

What the user finally sees is a list of people with their birthday today as shown in figure 5.8.2. This is because the `executeUndoableCommand()` which is overriden in the BirthdaysCommand class updates the `filteredPersonList`.
[source,java]
----
 @Override
    public CommandResult executeUndoableCommand() {
        model.updateFilteredPersonList(check);
        return new CommandResult(getBirthdayMessageSummary(model.getFilteredPersonList().size()));
    }
----

image::BirthdaysMechanism2.png[width="200"]
Figure 5.8.2 What the user sees

==== Design Considerations
**Aspect:** UI of `BirthdaysCommand` +
**Alternative 1 (current choice):** Showing the persons as a list +
**Pros:** g: Voluntary action. users can check birthday if they want to and won't get confused even if there are multiple contacts with the same name as to whose birthday it is +
**Cons:** Some users might want the birthdays to appear as a pop up +
**Alternative 2:** Use a pop up which is triggered when the app is opened +
**Pros:** Involuntary and less effort from the users' part +
**Cons:** If pop up only shows a list of names, users might get confused as to who the person is if there are multiple persons with the same name. +


//end::brithday[]
=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size


=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

link:#the-myths-book---developer-guide[Back To Top]

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.6.1 : Saving documentation as PDF files in Chrome_

link:#the-myths-book---developer-guide[Back To Top]

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

link:#the-myths-book---developer-guide[Back To Top]

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Suggested Programming Tasks to Get Started

Suggested path for new programmers:

1. First, add small local-impact (i.e. the impact of the change does not go beyond the component) enhancements to one component at a time. Some suggestions are given in this section link:#improving-each-component[Improving a Component].

2. Next, add a feature that touches multiple components to learn how to implement an end-to-end feature across all components. The section link:#creating-a-new-command-code-remark-code[Creating a new command: `remark`] explains how to go about adding such a feature.

=== Improving each component

Each individual exercise in this section is component-based (i.e. you would not need to modify the other components to get it to work).

[discrete]
==== `Logic` component

[TIP]
Do take a look at the link:#logic-component[Design: Logic Component] section before attempting to modify the `Logic` component.

. Add a shorthand equivalent alias for each of the individual commands. For example, besides typing `clear`, the user can also type `c` to remove all persons in the list.
+
****
* Hints
** Just like we store each individual command word constant `COMMAND_WORD` inside `*Command.java` (e.g.  link:{repoURL}/src/main/java/seedu/address/logic/commands/FindCommand.java[`FindCommand#COMMAND_WORD`], link:{repoURL}/src/main/java/seedu/address/logic/commands/DeleteCommand.java[`DeleteCommand#COMMAND_WORD`]), you need a new constant for aliases as well (e.g. `FindCommand#COMMAND_ALIAS`).
** link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] is responsible for analyzing command words.
* Solution
** Modify the switch statement in link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser#parseCommand(String)`] such that both the proper command word and alias can be used to execute the same intended command.
** See this https://github.com/se-edu/addressbook-level4/pull/590/files[PR] for the full solution.
****

[discrete]
==== `Model` component

[TIP]
Do take a look at the link:#model-component[Design: Model Component] section before attempting to modify the `Model` component.

. Add a `removeTag(Tag)` method. The specified tag will be removed from everyone in the address book.
+
****
* Hints
** The link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model`] API needs to be updated.
**  Find out which of the existing API methods in  link:{repoURL}/src/main/java/seedu/address/model/AddressBook.java[`AddressBook`] and link:{repoURL}/src/main/java/seedu/address/model/person/Person.java[`Person`] classes can be used to implement the tag removal logic. link:{repoURL}/src/main/java/seedu/address/model/AddressBook.java[`AddressBook`] allows you to update a person, and link:{repoURL}/src/main/java/seedu/address/model/person/Person.java[`Person`] allows you to update the tags.
* Solution
** Add the implementation of `deleteTag(Tag)` method in link:{repoURL}/src/main/java/seedu/address/model/ModelManager.java[`ModelManager`]. Loop through each person, and remove the `tag` from each person.
** See this https://github.com/se-edu/addressbook-level4/pull/591/files[PR] for the full solution.
****

[discrete]
==== `Ui` component

[TIP]
Do take a look at the link:#ui-component[Design: UI Component] section before attempting to modify the `UI` component.

. Use different colors for different tags inside person cards. For example, `friends` tags can be all in grey, and `colleagues` tags can be all in red.
+
**Before**
+
image::getting-started-ui-tag-before.png[width="300"]
+
**After**
+
image::getting-started-ui-tag-after.png[width="300"]
+
****
* Hints
** The tag labels are created inside link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard#initTags(ReadOnlyPerson)`] (`new Label(tag.tagName)`). https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Label.html[JavaFX's `Label` class] allows you to modify the style of each Label, such as changing its color.
** Use the .css attribute `-fx-background-color` to add a color.
* Solution
** See this https://github.com/se-edu/addressbook-level4/pull/592/files[PR] for the full solution.
****

. Modify link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] such that link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay`] can show a different style on error (currently it shows the same regardless of errors).
+
**Before**
+
image::getting-started-ui-result-before.png[width="200"]
+
**After**
+
image::getting-started-ui-result-after.png[width="200"]
+
****
* Hints
** link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] is raised by link:{repoURL}/src/main/java/seedu/address/ui/CommandBox.java[`CommandBox`] which also knows whether the result is a success or failure, and is caught by link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay`] which is where we want to change the style to.
** Refer to link:{repoURL}/src/main/java/seedu/address/ui/CommandBox.java[`CommandBox`] for an example on how to display an error.
* Solution
** Modify link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] 's constructor so that users of the event can indicate whether an error has occurred.
** Modify link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay#handleNewResultAvailableEvent(event)`] to react to this event appropriately.
** See this https://github.com/se-edu/addressbook-level4/pull/593/files[PR] for the full solution.
****

. Modify the link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] to show the total number of people in the address book.
+
**Before**
+
image::getting-started-ui-status-before.png[width="500"]
+
**After**
+
image::getting-started-ui-status-after.png[width="500"]
+
****
* Hints
** link:{repoURL}/src/main/resources/view/StatusBarFooter.fxml[`StatusBarFooter.fxml`] will need a new `StatusBar`. Be sure to set the `GridPane.columnIndex` properly for each `StatusBar` to avoid misalignment!
** link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] needs to initialize the status bar on application start, and to update it accordingly whenever the address book is updated.
* Solution
** Modify the constructor of link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] to take in the number of persons when the application just started.
** Use link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter#handleAddressBookChangedEvent(AddressBookChangedEvent)`] to update the number of persons whenever there are new changes to the addressbook.
** See this https://github.com/se-edu/addressbook-level4/pull/596/files[PR] for the full solution.
****

[discrete]
==== `Storage` component

[TIP]
Do take a look at the link:#storage-component[Design: Storage Component] section before attempting to modify the `Storage` component.

. Add a new method `backupAddressBook(ReadOnlyAddressBook)`, so that the address book can be saved in a fixed temporary location.

The new backUpAddressBook stores the address book at a back up location.

----
private AddressBookStorage backUpLocation;

public StorageManager(AddressBookStorage addressBookStorage, UserPrefsStorage userPrefsStorage) {
    super();
    this.addressBookStorage = addressBookStorage;
    this.userPrefsStorage = userPrefsStorage;
    this.backUpLocation = new XmlAddressBookStorage(addressBookStorage.getAddressBookFilePath());
}

public Optional<ReadOnlyAddressBook> readBackupAddressBook() throws DataConversionException, IOException {
    return readAddressBook(backUpLocation.getAddressBookFilePath());
}

private void backUpAddressBook(ReadOnlyAddressBook addressBook) throws IOException {
    String backupPath = backUpLocation.getAddressBookFilePath();
    logger.fine("Backing up data to: " + backupPath);
    saveAddressBook(addressBook, backupPath);
}
----

****
* Hint
** Add the API method in link:{repoURL}/src/main/java/seedu/address/storage/AddressBookStorage.java[`AddressBookStorage`] interface.
** Implement the logic in link:{repoURL}/src/main/java/seedu/address/storage/StorageManager.java[`StorageManager`] class.
* Solution
** See this https://github.com/se-edu/addressbook-level4/pull/594/files[PR] for the full solution.
****

=== Creating a new command: `remark`

By creating this command, you will get a chance to learn how to implement a feature end-to-end, touching all major components of the app.

==== Description
Edits the remark for a person specified in the `INDEX`. +
Format: `remark INDEX r/[REMARK]`

Examples:

* `remark 1 r/Likes to drink coffee.` +
Edits the remark for the first person to `Likes to drink coffee.`
* `remark 1 r/` +
Removes the remark for the first person.

==== Step-by-step Instructions

===== [Step 1] Logic: Teach the app to accept 'remark' which does nothing
Let's start by teaching the application how to parse a `remark` command. We will add the logic of `remark` later.

**Main:**

. Add a `RemarkCommand` that extends link:{repoURL}/src/main/java/seedu/address/logic/commands/UndoableCommand.java[`UndoableCommand`]. Upon execution, it should just throw an `Exception`.
. Modify link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] to accept a `RemarkCommand`.

**Tests:**

. Add `RemarkCommandTest` that tests that `executeUndoableCommand()` throws an Exception.
. Add new test method to link:{repoURL}/src/test/java/seedu/address/logic/parser/AddressBookParserTest.java[`AddressBookParserTest`], which tests that typing "remark" returns an instance of `RemarkCommand`.

===== [Step 2] Logic: Teach the app to accept 'remark' arguments
Let's teach the application to parse arguments that our `remark` command will accept. E.g. `1 r/Likes to drink coffee.`

**Main:**

. Modify `RemarkCommand` to take in an `Index` and `String` and print those two parameters as the error message.
. Add `RemarkCommandParser` that knows how to parse two arguments, one index and one with prefix 'r/'.
. Modify link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] to use the newly implemented `RemarkCommandParser`.

**Tests:**

. Modify `RemarkCommandTest` to test the `RemarkCommand#equals()` method.
. Add `RemarkCommandParserTest` that tests different boundary values
for `RemarkCommandParser`.
. Modify link:{repoURL}/src/test/java/seedu/address/logic/parser/AddressBookParserTest.java[`AddressBookParserTest`] to test that the correct command is generated according to the user input.

===== [Step 3] Ui: Add a placeholder for remark in `PersonCard`
Let's add a placeholder on all our link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] s to display a remark for each person later.

**Main:**

. Add a `Label` with any random text inside link:{repoURL}/src/main/resources/view/PersonListCard.fxml[`PersonListCard.fxml`].
. Add FXML annotation in link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] to tie the variable to the actual label.

**Tests:**

. Modify link:{repoURL}/src/test/java/guitests/guihandles/PersonCardHandle.java[`PersonCardHandle`] so that future tests can read the contents of the remark label.

===== [Step 4] Model: Add `Remark` class
We have to properly encapsulate the remark in our link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`] class. Instead of just using a `String`, let's follow the conventional class structure that the codebase already uses by adding a `Remark` class.

**Main:**

. Add `Remark` to model component (you can copy from link:{repoURL}/src/main/java/seedu/address/model/person/Address.java[`Address`], remove the regex and change the names accordingly).
. Modify `RemarkCommand` to now take in a `Remark` instead of a `String`.

**Tests:**

. Add test for `Remark`, to test the `Remark#equals()` method.

===== [Step 5] Model: Modify `ReadOnlyPerson` to support a `Remark` field
Now we have the `Remark` class, we need to actually use it inside link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`].

**Main:**

. Add three methods `setRemark(Remark)`, `getRemark()` and `remarkProperty()`. Be sure to implement these newly created methods in link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`Person`], which implements the link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`] interface.
. You may assume that the user will not be able to use the `add` and `edit` commands to modify the remarks field (i.e. the person will be created without a remark).
. Modify link:{repoURL}/src/main/java/seedu/address/model/util/SampleDataUtil.java/[`SampleDataUtil`] to add remarks for the sample data (delete your `addressBook.xml` so that the application will load the sample data when you launch it.)

===== [Step 6] Storage: Add `Remark` field to `XmlAdaptedPerson` class
We now have `Remark` s for `Person` s, but they will be gone when we exit the application. Let's modify link:{repoURL}/src/main/java/seedu/address/storage/XmlAdaptedPerson.java[`XmlAdaptedPerson`] to include a `Remark` field so that it will be saved.

**Main:**

. Add a new Xml field for `Remark`.
. Be sure to modify the logic of the constructor and `toModelType()`, which handles the conversion to/from  link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`].

**Tests:**

. Fix `validAddressBook.xml` such that the XML tests will not fail due to a missing `<remark>` element.

===== [Step 7] Ui: Connect `Remark` field to `PersonCard`
Our remark label in link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] is still a placeholder. Let's bring it to life by binding it with the actual `remark` field.

**Main:**

. Modify link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard#bindListeners()`] to add the binding for `remark`.

**Tests:**

. Modify link:{repoURL}/src/test/java/seedu/address/ui/testutil/GuiTestAssert.java[`GuiTestAssert#assertCardDisplaysPerson(...)`] so that it will compare the remark label.
. In link:{repoURL}/src/test/java/seedu/address/ui/PersonCardTest.java[`PersonCardTest`], call `personWithTags.setRemark(ALICE.getRemark())` to test that changes in the link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`Person`] 's remark correctly updates the corresponding link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`].

===== [Step 8] Logic: Implement `RemarkCommand#execute()` logic
We now have everything set up... but we still can't modify the remarks. Let's finish it up by adding in actual logic for our `remark` command.

**Main:**

. Replace the logic in `RemarkCommand#execute()` (that currently just throws an `Exception`), with the actual logic to modify the remarks of a person.

**Tests:**

. Update `RemarkCommandTest` to test that the `execute()` logic works.

==== Full Solution

See this https://github.com/se-edu/addressbook-level4/pull/599[PR] for the step-by-step solution.

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |user |add a new person |store more information about people around me

|`* * *` |user |delete a person |remove entries that I no longer need

|`* * *` |user |request for a help guide |know more about the address book and use it with less difficulty

|`* * *` |user |list and view all my contacts |browse through my stored contacts and in the event of not being able to search for them

|`* * *` |user |edit a person's information |constantly update or correct a contact's information

|`* * *` |user |select a person by index |use the information provided to search on Google

|`* * *` |user |view the history of the commands inputted |know which steps have been made to the addressbook

|`* * *` |user |undo the commands that were inputted |revert unnecessary or unwanted changes

|`* * *` |user |redo the commands that is undone |revert changes that were undone

|`* * *` |user |clear entries in my addressbook |remove unnecessary information of my contacts or remake a new contact list

|`* * *` |user |exit the program |

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |have a CLI prompt that can exhibit the required information to add an individual  |avoid inputting the wrong information

|`* * *` |user |store multiple phone numbers and email addresses for any contact |store extra communication information of my contact

|`* * *` |social user |access Facebook, LinkedIn and Google |search and add my contacts on respective websites

|`* * *` |user |have a confirmation request of the details inputted before adding an individual|make changes to any errors inputted

|`* * *` |responsible user |have a confirmation request & warning message upon using the clear command |avoid accidentally clearing my address book

|`* * *` |user |find contacts based on part of their names |ease the search for the necessary contacts without being too specific in spelling names

|`* * *` |user |find users based on any of their details (i.e. phone or tag) |find the person more easily

|`* * *` |user |have a filter system to find contacts first by name, and then any additional relevant information(tags or email addresses) |search for a person more accurately in the case of multiple people with similar names.

|`* * *` |organized user |sort my contacts in an alphabetical order |view my overall contact list in an alphabetically organized manner

|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else seeing them by accident

|`* *` |user |have directions to the contact's address with Google Maps from current location |have direct and easier access in being referred to the location in Google Maps application

|`* *` |user |choose various colour themes for the address book |view the address book in my favourite visuals

|`* *` |social user |add some important people to a favourites list |access my favourite contacts easily

|`* *` |task-oriented user |see my most viewed contacts on a "speed check" tab |search quickly for contacts that i often search for based on the number of times i searched for them

|`* *` |task-oriented user |sort the list of contacts based on their details |view contacts based on my preferable detail i am wishing to search for

|`* *` |responsible user |save my contacts list in a portable format |keep a soft copy of it and be able to retrieve if i lost my original contact list or want to access it in another computer

|`* *` |social user |add organisations/groups |search for individuals based on their organization groups

|`* *` |social user |store internet links to their organization website, github, linkedIn or facebook |more information on my contacts

|`* *` |social user |have the option to add a picture of an individual |recognize contacts by their facial features.

|`* *` |task-oriented user |get reminders |know if i am attending an event with another contact, or if it is the contact's birthday

|`* *` |task-oriented user |be able to create appointments with my contacts |be notified of my upcoming meetings

|`* *` |social user |add birthday information to my contact in the address book |have easier access to the upcoming birthday dates of the people around me

|=======================================================================

Social user - a user who likes to know more information about the people around them so as to understand them better +
Task-oriented user - a user who prefers to have purposeful functions which would help facilitate easier access towards executing his work +
{More to be added}

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Use Cases

(For all use cases below, the *System* is the `AddressBook` and the *Actor* is the `user`, unless specified otherwise)

=== Use case: Delete person

*MSS*

1.  User requests to list persons
2.  AddressBook shows a list of persons
3.  User requests to delete a specific person in the list
4.  AddressBook deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

=== Use case: Sort list

*MSS*

1.  User requests to list persons
2.  AddressBook shows a list of persons
3.  User requests to sort list
4.  AddressBook sorts the list of persons
5.  AddressBook shows sorted list of persons
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

[none]
* 5a. The list is empty.
+
Use case ends.

=== Use case: Find person

*MSS*

1.  User requests to find person with keyword (name or first few characters of name)
2.  AddressBook shows a list of persons with keyword
+
Use case ends.

*Extensions*

=== Use case: Add person

*MSS*

1.  User requests to add person
2.  User types in details of person to add
3.  AddressBook shows details of person to add
4.  AddressBook requests confirmation to add person
5.  User confirms adding of person
6.  AddressBook adds person to list of persons
7.  AddressBook shows updated list of persons with added person
+
Use case ends.

*Extensions*

* 2a. Details are invalid.
+
[none]
** 2a1. AddressBook shows an error message.
+
Use case resumes at step 1.

* 5a. User denies adding of person.
+
[none]
** 5a1. AddressBook requests details to edit
** 5a2. User types in new, edited details
+
Use case resumes at step 3.

=== Use case: Undo command

*MSS*

1.  User uses add, delete, edit or clear command
2.  User requests undo of command
3.  AddressBook returns to the state before the command
4.  AddressBook shows updated state
+
Use case ends.

*Extensions*

* 2a. No more commands to undo.

+
[none]
** 2a1. AddressBook shows an error message.
+
Use case ends.

=== Use case: List persons

*MSS*

1.  User requests to list persons
2.  AddressBook shows a list of persons
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

=== Use case: Add event

*MSS*

1. User requests to add event
2. User types in details of event to add
3. AddressBook shows details of event to add
4. AddressBook request confirmation to add event
5. User confirms adding of event
6. AddressBok adds event to list of events

Use case ends
{More to be added}

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be able to work for 32-bit and 64-bit systems.
.  Should be able to respond within a second.
.  Should be able to be used by any individual who has not used an address book before.
.  The source code should be open source.
.  Should maintain application every month.
.  Should be able to retrieve, save and use on another computer.
.  A user should be able to back up and restore all contacts if application breakdown.

{More to be added}

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[abstract]]
Abstract

....
An abstract class is a class that is declared abstract—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.
An abstract method is a method that is declared without an implementation
....

[[API]]
API

....
Application Programming Interface (API)is a collection of pre-written packages,
classes, and interfaces with their respective methods, fields and constructors.
....

[[javaFX]]
JavaFX

....
JavaFX is a software platform for creating and delivering desktop applications,
as well as rich internet applications (RIAs) that can run across a wide variety of devices.
....

[[gradle]]
Gradle

....
Gradle is an open source build automation system that builds upon the concepts of Apache Ant and Apache Maven.
....

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

link:#the-myths-book---developer-guide[Back To Top]
