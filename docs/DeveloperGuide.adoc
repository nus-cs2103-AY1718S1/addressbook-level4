= Ark - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-T16-B1/main/tree/master

By: `CS2103AUG2017 Team T16-B1`      Since: `Sept 2017`      Licence: `MIT`

== Introduction

=== What is Ark?
Ark is a Command Line Interface software that helps delivery and shipping vendors manage their parcels and deliveries.
Ark allows these delivery companies to track the parcels that they have to deliver to their customers, and empowers
delivery vendors with simple end-to-end management of these deliveries. Ark also provides route optimization features
to help vendors optimize their deliveries based on time or distance.

=== About this guide
The purpose of this developer guide is to help incoming developers, project managers and executives understand the
high-level details of the Ark software and help them develop code in coherence with our guidelines. Such details
include the Ark architecture and system, its components and the interaction between these components. +

This guide contains information pertaining to issues such as: +

* Setting up the development environment for Ark.
* Understanding the high-level components of Ark.
* Understanding the various features and their implementations in Ark.
* Adding documentation to document the changes you have made.
* Running tests for the code in Ark.
* Details on how to manage the Ark project using Version Control and Continuous Integration.

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project
dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should
finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://oss-generic.github.io/process/codingStandards/CodingStandard-Java.html[oss-generic coding
standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To
rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent
IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`,
`import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check
style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `CS2103AUG2017-T16-B1/main` repo. If you
plan to develop this as a separate product (i.e. instead of contributing to the `CS2103AUG2017-T16-B1/main`) ,
you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the
URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how
to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms
(Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

Before you start contributing to Ark, get some sense of the overall design by reading the
 link:#architecture[Architecture] section.

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 3.1.1 : Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of
each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams]
folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save
as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible
for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those
classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus
library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface
and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 3.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command
`delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 3.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the address book data are changed, instead of
asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being
saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 3.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be
coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between
components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagram.png[width="800"]
_Figure 3.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `ParcelListPanel`,
`StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that
are in the `src/main/resources/view` folder. For example, the layout of the
link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in
link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 3.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 3.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand`
and `Command` in Figure 3.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a parcel) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API
call.

image::DeleteParcelSdForLogic.png[width="800"]
_Figure 3.3.3 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagram.png[width="800"]
_Figure 3.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the data from interactions with AddressBook.
* exposes an unmodifiable `ObservableList<ReadOnlyParcel>` that can be 'observed' e.g. the UI can be bound to this list
so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagram.png[width="800"]
_Figure 3.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing
and redoing of commands that modifies the state of address book (e.g. `add`, `edit`). Such commands will inherit from
`UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead.
The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]
_Figure 4.1.1 : Inheritance diagram for commands_

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and
concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing
a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand`
contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute
the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level
steps of the algorithm in child classes is also known as the
https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th parcel in the address book. The current state
of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto
the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]
_Figure 4.1.2 : State of the undoStack and redoStack after `delete 5` is executed_

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may
execute `add n/David ...` to add a new parcel.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]
_Figure 4.1.2 : State of the undoStack and redoStack after `add n/David` is executed_
[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the parcel was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the
address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]
_Figure 4.1.3 : State of the undoStack and redoStack after `undo` is executed_
[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when
popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]
_Figure 4.1.4 : Sequence diagram of the undo operation_

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the
state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when
popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This
time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command
(this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]
_Figure 4.1.5 : State of the undoStack and redoStack after `clear` is executed_

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command`
rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]
_Figure 4.1.6 : State of the undoStack and redoStack after `list` is executed_

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]
_Figure 4.1.7 : The activity diagram describing what happens inside the `UndoRedoStack` when the user executes a new
command_

==== Design Considerations

**Aspect: Implementation of `UndoableCommand`** +

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()` +
** **Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that
deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
** **Cons:** Hard for new developers to understand the template pattern. +
* **Alternative 2:** Just override `execute()` +
** **Pros:** Does not involve the template pattern, easier for new developers to understand. +
** **Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to
undo/redo.

---

**Aspect: How undo & redo executes** +

* **Alternative 1 (current choice):** Saves the entire address book. +
** **Pros:** Easy to implement. +
** **Cons:** May have performance issues in terms of memory usage. +
* **Alternative 2:** Individual command knows how to undo/redo by itself. +
** **Pros:** Will use less memory (e.g. for `delete`, just save the parcel being deleted). +
** **Cons:** We must ensure that the implementation of each individual command are correct.

---

* **Aspect: Type of commands that can be undone/redone** +

* **Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
** **Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are
lost). +
** **Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to
realize that it does not do that, after executing `undo`. +
* **Alternative 2:** Include all commands. +
** **Pros:** Might be more intuitive for the user. +
** **Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and
not the view. +
** **Additional Info:** See our discussion
https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect: Data structure to support the undo/redo commands** +

* **Alternative 1 (current choice):** Use separate stack for undo and redo +
** **Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the
new incoming developers of our project. +
** **Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both
`HistoryManager` and `UndoRedoStack`. +
* **Alternative 2:** Use `HistoryManager` for undo/redo +
** **Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
** **Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands.
Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different
things. +
// end::undoredo[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and
logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file
(See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the
specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of
just its size

=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file
(default: `config.json`).

//tag::browser[]
=== Google Maps Search Browser

The google maps search browser enhancement resides within the `BrowserPanel`.
It takes in a `ReadOnlyParcel` 's postal code number substring of the parcel's address and concatenates it
to the back of Google Map's search URL prefix to get a URL for the browser to load.

==== Design Considerations

**Aspect: Implementation of Google Maps Search Browser** +

* **Alternative 1 (current choice):** Change browser loadPage URL to Google Map search URL +
** **Pros:** Its easy to implement new methods to load a new URLs if required to display a different URL. +
** **Cons:** The map has no other functionality besides searching for the postal code. +
* **Alternative 2 (future implementation choice):** Implementing through Google Maps API +
** **Pros:** Makes it easier for implementing additional features that utilizes the Maps API which would be required +
 in future versions of the Ark application. +
** **Cons:** More difficult to implement and integrate into a command line interface.
//end::browser[]

//tag::deleteTag[]

=== Delete Tag mechanism

The delete tag mechanism is facilitated by a `deleteTag` method within the `ModelManager`. It supports the deletion
of tags from every single parcel in Ark.

We first retrieve the list of parcels in Ark and iterate through each parcel and recreate the parcel object using the
original parcel. We then check if tag we want to remove is present in the new parcel's list of tags. If the tag is
present, we remove it, otherwise, we do nothing. We then update the old parcel in Ark with the new parcel with the
updated list of tags.

==== Design Considerations

**Aspect: Implementation of `deleteTagCommand`** +

* **Alternative 1 (current choice):** Add method to delete tags in `ModelManager` +
** **Pros:** It is easy to implement a method to remove every instance where the Tag appears, we only have to be able to
correctly iterate through all the lists of tags. +
** **Cons:** Might be computationally expensive for large number of parcels as Ark will need to iterate through every
Tag to delete them. +
* **Alternative 2:** Maintain a list of tags and where the tags are located+
** **Pros:** Computationally quicker to just find the tag and remove the tag from every parcel in the list of tags +
** **Cons:** More difficult to implement as we have to store an additional list of tags which is linked to each parcel
and has to be updated whenever we edit other parcel details as well.

//end::deleteTag[]

//tag::backup[]

=== Backup Mechanism

The back up mechanism is facilitated by a `backupAddressBook()` method within the `StorageManager`. It supports the
backing up of AddressBook data in Ark. +

image::BackupSequenceDiagram.png[width="600"]
_Figure 4.6.1 : Sequence diagram describing the operation of the `storageManager` when it is initialized_

The `backupAddressBook()` method is called automatically when `storageManager` is initialised in `MainApp#init()`,
a method that is called when `Ark` is launched. The method utilises the `StorageManager#saveAddressBook()` method and
stores the backup in the same directory as the main `AddressBook` storage file. The backup file is saved and named with
the name of the main `AddressBook` storage file appended with `-backup.xml`. i.e. If the main `AddressBook` storage file
 is named as `addressbook.xml`, the backup storage file will be saved as `addressbook.xml-backup.xml`.

//end::backup[]

==== Design Considerations

**Aspect: Implementation of `StorageManager#backupAddressBook`** +

* **Alternative 1 (current choice):** use the `aveAddressBook()` method to implement logic. +
** **Pros:** It becomes easier to implement method rather than writing out a separate logic for `backupAddressBook()`. It
makes updates easier since enhancements to `saveAddressBook()` will also enhance `backupAddressBook()`. +
** **Cons:** This implementation increases the coupling of `backupAddressBook()` and
`saveAddressBook()` where changes in `saveAddressBook()` are likely to cause changes in `backupAddressBook()`. +
* **Alternative 2:** Separate the implementation of `backupAddressBook()` from `saveAddressBook()` +
** **Pros:** Reduced coupling of `saveAddressBook()` and `backupAddressBook()` and allows the backup file to be saved at a
different location from the main save file. This prevents the backup file from being corrupted if the folder of the
main save file becomes corrupted. +
** **Cons:** More tedious to implement and maintain `backupAddressBook()` since enhancements to the saving feature has to
be implemented in both `saveAddressBook()` and `backupAddressBook()` +

---

**Aspect: Trigger to execute `backupAddressBook`** +
* **Alternative 1 (current choice):** Automatically backup data on Ark on launch of the software. +
** **Pros:** This implementation ensures that the if the user corrupts the data of Ark during a session. The user will be
able to revert to the start of the session, which is ensured to be a workable instance of the Ark software. +
** **Cons:** This does not give the most recent copy of the data of the Ark if many changes were made in a single session. +
* **Alternative 2:** Backup data on Ark every few minutes +
** **Pros:** Provides a very recent copy of the data on Ark. +
** **Cons:** More tedious and difficult to implement. User may also be running another process at that point of time. It
could cause a bottleneck if there is a lot of data to be saved, and multiple backup calls are queued one after the
other. +
* **Alternative 3:** Backup data after a fixed number of `UndoableCommand`s. +
** **Pros:** Provides a very recent copy of the data on Ark. +
** **Cons:** More tedious and difficult to implement. Difficult to determine the optimal amount of data to restore. If
the corruption of the data is caused by a several of commands, it becomes difficult to ensure that the backup file
provides a workable copy of the data of Ark.

//tag::import[]

=== Import Mechanism

To use this command, type `import (FILE_NAME)` into the `CommandBox`.

The `Import` mechanism allows users to import parcels from valid `Ark` storage files stored as `.xml` files into the
current instance of `Ark`. This mecahnism is facilitated by a `readAddressBook` method within`XmlAddressBookStorage` to
load the parcels stored in the `xml` file and an `addAllParcels` method defined in `ModelManager` to add the parcels in
the storage file into the current instance of `Ark`. +

Since the `Import` mechanism modifies the state of the data in `Ark`, it has to be undoable. Thus, it inherits from
`UndoableCommands` interface rather than inheriting from the `Command` interface directly. +

[NOTE]
The file to be imported has to be stored in the `./data/import` folder. i.e. calling `import ark.xml` will import the
file `./data/import/ark.xml`. +
If the user enters a file name that is not alphanumeric or a file name that is not in a `.xml` format, the parcel will
throw an Exception. This is to prevent a directory traversal attack on Ark. Read more about directory traversal
attacks link:https://www.acunetix.com/websitesecurity/directory-traversal/[here] +

The following sequence diagram shows how the `import` operation works:

image::ImportSequenceDiagram.png[width="1000"]
_Figure 4.7.1 : Sequence diagram describing the operation of `import` when it is executed_

[NOTE]
The `ImportCommand` will only add parcels non-duplicate parcels. Duplicate parcels are ignored. If all the parcels to be
 imported into Ark are duplicates, then no parcels are imported and an Exception is thrown.

==== Design Considerations

**Aspect: Implementation of `ImportCommand`** +

* **Alternative 1 (current choice): using `readAddressBook()` to implement the logic `ImportCommand`** +
** **Pros:** It becomes easier to implement method rather than writing out a separate logic to import files. It
makes updates easier since enhancements to `readAddressBook()` will also enhance the import command such as
more supported save file formats. +
** **Cons:** This implementation increases the coupling of the `readAddressBook()` and `ImportCommand` such that changes
 in `readAddressBook()` is likely to cause a change in `ImportCommand`. +
* **Alternative 2:** Implement a parsing logic for `ImportCommand`.
** **Pros:** Reduced coupling of `readAddressBook()` and `ImportCommand`. This gives the developers more freedom on
 adding more file formats that can be imported. +
** **Cons:** More tedious to implement and maintain `ImportCommand` since enhancements to the `readAddressBook()`
feature has to be manually implemented in `ImportCommand` as well.

---

**Aspect: Arguments to import files** +

* **Alternative 1 (current choice):** Backup save files from only one location +
** **Pros:** User will only stored his save files at one location, he will not store them at random locations and lose
track of them. User only has to type the name of the file and does not need to type the full file path to locate
the file. i.e. the user does not need to type `./data/import/Ark.xml`. +
** **Cons:** The user has restrictions on where he can import files from. +
* **Alternative 2:** User can load the files from any directory +
** **Pros:** Allows user to import from his own archived folders anywhere in this computer. +
** **Cons:** More tedious for the user to type in the full file path to locate the .xml file that he wants to import. +

---

**Aspect: Allowed file names that can be imported** +

* **Alternative 1 (current choice):** File Names can only be alphanumeric and be in the `.xml` format. +
** **Pros:** Ark is protected from directory traversal attacks. +
** **Cons:** The user has restrictions on the file naming conventions he can use to name his import files +
* **Alternative 2:** No file name check +
** **Pros:** Allows user to name his files following any conventions and be successfully imported into Ark. +
** **Cons:** Makes Ark vulnerable to simple directory traversal attack where user can access files outside the
`data/import/` directory. +

//end::import[]

//tag::autocomplete[]

=== Tab autocomplete mechanism

image::SDforTabAutocomplete.png[width="900"]
_Figure 4.8.1 : Sequence Diagram describing the operation of the `Autocompleter` when `autocomplete` is executed_

The tab autocomplete mechanism is facilitated by the `autocomplete` method residing inside the `Autocompleter`.
It supports the tab autocompletion for possible commands that that match the text in the CommandBox. +

A new `Autocompleter` is initialized when the `CommandBox` is initialized as an attribute of the `CommandBox`. When
the `tab` key is pressed by the user, `CommandBox#processAutocomplete` retrieves the text that is currently in
the `commandTextField` and passes it into the `Autocompleter#autocomplete` as a string. If the string is empty,
`autocomplete` raises a `NewResultAvailableEvent` to prompt the user to use the help command and returns
an empty string. +

If the string is not empty, the text in `commandTextField` will be converted into an array and stored in
`commandBoxTextArray`. If there is only one word in the `commandBoxTextArray`,
`AutoCompleter#processOneWordAutocomplete` will be called and the only word in commandBoxTextArray is passed in as a
string `commandBoxText`. `processOneWordAutocomplete` will then pass `commandBoxText` into `getClosestCommands`.
`getClosestCommands` then iterates through all the possible commands in `commandList` and compares them with
`commandBoxText` using  `AutoComplete#isPossibleMatch` . If `isPossibleMatch` returns true, the command is then stored
inside the arrayList `possibleResults`. After iterating through `commandList`, `getClosestCommands` then returns
`possibleResults`. If there is only one item inside `possibleResults`, `processOneWordAutoComplete` will return it to
`autocomplete` which then returns it to `processAutocomplete`. If there is more than one item, a
`NewResultAvailableEvent` is raised which prompts the user on the possible autocomplete commands available and returns
the original value of `commandBoxText`. +

After `autocomplete` returns a string to `processAutocomplete`, it then passes the string into `CommandBox#replaceText`
to replace the text in `commandFieldText` with the string. +

==== Design Considerations

**Aspect: Implementation of `autocomplete`** +

* **Alternative 1 (current choice):** Create a new `Autocompleter` class to implement `autocomplete` and its helper
functions. +
** **Pros:** Single Responsibility Principle (SRP) is maintained +
** **Cons:** More tedious to implement and test since the feature is implemented in both `Autocompleter` and `CommandBox`.
Also creates coupling between the `Autocompleter` and `CommandBox`. +
* **Alternative 2:** Implement `autocomplete` inside `CommandBox`
** **Pros:** Easier to test since `CommandBoxTest` has already been set up and implemented. +
** **Cons:** `CommandBox` class now has multiple responsibilities, which violates SRP. +=== Tab autocomplete mechanism

//end::autocomplete[]

//tag::trackingNumber[]

=== TrackingNumber Field

Parcels have tracking numbers for delivery vendors to keep track of the parcels that they send out on a daily basis.
This feature is important because a single person can have many parcels belonging to him. Tracking numbers are used
to differentiate between the different parcels that are going to be delivered to the same person. Tracking numbers also
serve as a better way of narrowing down and pinpointing parcels of interest since these numbers are more unique

[NOTE]
Presently, the `Tracking Number` Field only has support for Registered Article tracking numbers belonging to SingPost.
You can read more about their Registered Article tracking number
 link:http://www.singpost.com/send-receive/sending-within-singapore/registered-article-local[here].

//end::trackingNumber[]

//tag::postalCode[]

=== PostalCode Field

The `PostalCode` field is implemented as part of Address. This class stores the postal address of locations in Singapore.
It only accepts values of `s` or `S` followed by 6 digits. The value stored in this class is used to store the postal
code of the address. The value is used to query Google Maps when the `select` command is executed.

[NOTE]
Presently, the `PostalCode` field still does a very relaxed validation and does not completely ensure that the postal
code exists even though it might meet the criteria above. The team is working on producing a database of postal codes
 in Singapore by quering the Google Maps Distance Matrix API. In the meantime, it is assumed that users will enter
 the correct postal code.

//end::postalCode[]

//tag::status[]

=== Status field

`Status` is used to indicate the current stage of delivery that a parcel is at. It has 4 possible states:

* `PENDING` - This means that the parcel has not been delivered and has not passed the date it is supposed to be
delivered by. +
* `DELIVERING` - This means that the parcel is currently working being delivered to its destination address.
* `COMPLETED` - This indicates that the parcel has been successfully delivered to its destination.
* `OVERDUE` - This state indicates that the parcel has not been delivered and has passed its due date.

These states have different colours codes to allow users to differentiate the `Status` values more easily.

==== Design Considerations

** `Implementation of Status`**

* **Alternative 1 (current choice):** Status is an enum class.
** **Pros:** `Status` should only have fixed values. The user should also not be allowed to create new `Status` objects.
** **Cons:** Less options for the user to alter the `Status` values +
* **Alternative 2:** Allow the user to define any `Status` they wish.
** **Pros:** Users have more versatility on naming conventions
** **Cons:** It becomes more difficult to import data files since different users may use different terminologies to
describe the same status of the parcel.

//end::status[]

//tag::deliveryDate[]
=== Delivery Date field

`Delivery Date` is used to indicate the delivery date that the parcel must be delivered by.
The dates are only accepted if they are valid. The parcel list is maintained in sorted order by comparing
their delivery dates, with the earliest on top.

//end::deliveryDate[]

//tag::tags[]
=== Tags

`Tag`s are used to indicate how the parcel should be handled. Tags can contain one or more of the following `Tag`s:

* `FROZEN` - This means the parcel should be refrigerated as its contents are temperature sensitive.
* `FLAMMABLE` - This means that the parcels' contents are highly flammable and should be kept away from heat.
* `HEAVY` - This indicates that the parcel is heavy and may require additional manpower to deliver.
* `FRAGILE` - This state indicates that the parcels' contents can be broken easily and
requires additional care when handling.

==== Design Considerations

** `Implementation of Tag`**

* **Alternative 1 (current choice):** Tag is an enum class.
** **Pros:** `Tag`s should only have fixed values. The user should also not be allowed to create new `Tag` objects.
** **Cons:** Less options for the user to alter the `Tag` values +
* **Alternative 2:** Allow the user to define any `Tag`s they wish.
** **Pros:** Users have more versatility on naming conventions
** **Cons:** It becomes difficult for delivery personnel to keep track of the tags since different personnel might
use different tag names to refer to the same tag.

//end::tags[]

//tag::sortedList[]

=== Maintain sorted mechanism
image::AddParcelSdForLOgic.png[width="890"]
_Figure 4.13.1 : Adding Alice to Ark, maintainSorted is actually called and returns void._

The list of parcels in Ark is maintained to be always in sorted order according to delivery dates,
with the earliest being on the top. This is so that the user will be able to look at the more
pertinent deliveries. +

The list is sorted whenever a parcel is added, edited or if a redo command is made. This is
because these commands are the ones that might possibly cause the new parcel to be placed
in the wrong position. +

To maintain the selected element despite sorting however, we require a way to track which parcel
is selected. Static variables to track which card has been selected has been added to the Model
class. The Model class now has the following methods: `select`, `unselect`, `getPrevIndex`,
`hasSelected` and `forceSelect`. Whenever we select an item, we will use `select` to indicate that
we have selected a parcel card and we will then re-select that particular card after we have sorted. +

==== Design Considerations

**Aspect:** Implementation of `maintainSorted` +
**Alternative 1 (current choice):** Constant sort the list of parcels whenever there is a change that
potentially could disrupt the order of the list. +
**Pros:** Intuitive and guarantees that list is sorted in the right order +
**Cons:** Many commands have to be changed +
**Alternative 2:** Insert the new / edited parcel to fit into the sorted list. +
**Pros:** Use less computation as the list of parcels is already sorted. +
**Cons:** More difficult to implement as we'll need to implement our own sorting algorithm as opposed to
just using the built in sorting methods. +

//tag::sortedList[]

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility
in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview
the end result of your edits. Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to
preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as
Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files
in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` ->
`Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results,
use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.3.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to
platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode.
In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the
Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux:
`./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be
working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected
together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on
our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you
created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the
http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated
using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="8%,<17%,<30%,<45%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |onging user |have a backup of my addressbook data |restore my addressbook if the storage file becomes corrupted

|`* * *` |user |add a new parcel |

|`* * *` |user |delete a parcel |

|`* * *` |user |find a parcel by name |locate details of parcels without having to go through the entire list

|`* * *` |user |filter parcels by tags |view specific parcels that are assigned with specific tags

|`* * *` |user |the browser to automatically search for the address of the selected parcel in Google Maps | so that
I can automatically get information on how to get to an address automatically, on click.

|`* * *` |delivery man who travels a lot |to know the shortest distance from one contact's address to another |

|`* * *` |delivery man who travels a lot |set a reference location |find the shortest distance from my reference
location to a parcel's delivery location

|`* * *` |delivery company |be able to keep track of my deliveries |deliver the packages on time

|`* * *` |delivery company |be alerted for any deliveries to be done today |deliver the packages on time

|`* * *` |delivery company |sort my deliveries by date |know which packages are more urgent to handle

|`* * *` |delivery man|generate deliver route based on my list of deliveries |know schedule for the day

|`* * *` |delivery company |add a list of deliveries in one shot using Comma Separated Values |conveniently parse
information from other sources

|`* * *` |delivery company |add deliveries individually |

|`* * *` |delivery company |check for deliveries close to deadline |better prepare for busy periods

|`* * *` |delivery company |archive completed deliveries |refer to them in the future

|`* *` |new user |to have an autocomplete for the commands |I do not need to remember the format of commands

|`* *` |user |store the sender and receiver addresses |use these addresses as destinations/sources of my deliveries

|`* *` |lazy user |send and receive parcel details to and from other companies |minimize the amount of data inputs

|`* *` |forgetful user |be reminded of a parcel's delivery date (if valid) |in case I forget the date

|`* *` |user |share details with contacts with a specific tag |minimize chance of someone else seeing them by accident

|`* *` |busy user |add and remove tasks |use addressbook as a task manager

|`* *` |user with a changing schedule |edit created tasks |change the details of task

|`* *` |user |assign contacts and locations to tasks |link my tasks with people and places

|`* *` |user |assign an expiry date to tasks |tasks are deleted automatically

|`* *` |lazy user |to be notified of the most optimal path of completing my deliveries based on travelling distance |

|`* *` |user |filter tasks according to location |be notified of deliveries I have at a specific location

|`* *` |forgetful user |view daily deliveries |keep track of daily deliveries

|`* *` |user |retrieve my exact location on my device |remember the current address and store my location

|`*` |new user |input instructions into a chatbot interface |I do not need to remember the format of commands

|`*` |user with many parcels in the address book |sort parcels by name |locate a parcel easily
|=======================================================================

{More to be added}

[appendix]
== Use Cases

(For all use cases below, the *System* is the `AddressBook` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete parcel

*MSS*

1.  User requests to list parcels
2.  AddressBook shows a list of parcels and maximizes the `ParcelListPanel` in the `MainWindow` UI
3.  User requests to delete a specific parcel in the list
4.  AddressBook deletes the parcel
+
Use case ends

*Extensions*

[none]
* 2a. The list is empty
+
Use case ends

* 3a. The given index is invalid
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2

[discrete]
=== Use case: Add parcel by prompt

*MSS*

1.  User requests to add parcels without further details
2.  AddressBook prompts user to input parcel identification number of parcel to add
3.  User inputs identification number as requested
4.  AddressBook prompts user to input name of recipient of parcel to add
5.  User inputs name of recipient as requested
6.  AddressBook prompts user to input phone number of recipient of parcel to add
7.  User inputs phone number as requested
8.  AddressBook prompts user to input email of recipient of parcel to add
9.  User inputs email as requested
10.  AddressBook prompts user to input delivery address of parcel to add
11.  User inputs address as requested
12.  AddressBook prompts user to input tags of parcel to add
13.  User inputs tags as requested [optional]
14.  AddressBook adds parcel
+
Use case ends

*Extensions*

[none]
* 3a. The user does not input a parcel identification number
+
[none]
** 3a1. AddressBook shows an error message
+
Use case resumes at step 2

[none]
* 5a. The user does not input a name
+
[none]
** 5a1. AddressBook shows an error message
+
Use case resumes at step 4

* 7a. The user does not input a valid phone number
+
[none]
** 7a1. AddressBook shows an error message
+
Use case resumes at step 6

[none]
* 9a. The user does not input a valid email
+
[none]
** 9a1. AddressBook shows an error message
+
Use case resumes at step 8

* 11a. The user does not input a valid address
+
[none]
** 11a1. AddressBook shows an error message
+
Use case resumes at step 10

* 13a. The user does not input a tag
+
[none]
** 13a1. AddressBook shows that no tag has been entered
+
Use case resumes at step 14

[none]
* 14. AddressBook shows error message if same parcel found
+
Use case ends


[discrete]
=== Use case: Upload image of Parcel from local files

*MSS*

1.  User requests to list parcels
2.  AddressBook shows a list of parcels and maximizes the `ParcelListPanel` in the `MainWindow` UI
3.  User requests to upload image of a specific parcel in the list
4.  AddressBook prompts for location of image
5.  User inputs file path
6.  AddressBook updates image
+
Use case ends

*Extensions*

[none]
* 2a. The list is empty
+
Use case ends.

* 6a. The file path given is invalid
+
[none]
** 6a1. AddressBook shows an error message
+
Use case resumes at step 4

* 6b. The file type of file given is invalid
+
[none]
** 6b1. AddressBook shows an error message
+
Use case resumes at step 4

[discrete]
=== Use case: Set user reference location

*MSS*

1.  User requests to set reference location
2.  AddressBook updates reference location
+
Use case ends

{More to be added}

[appendix]
== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 parcels without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be
able to accomplish most of the tasks faster using commands than using the mouse.
.  Each Command should take at most 1 second to finish execution.
.  Should be able to handle any valid or invalid user input.
.  Should back up data inside the address book each time the user makes changes to the data.
.  Commands that do not require internet connection should still work when the user is not connected to the internet.
.  Should come with automated unit tests.
.  A new user should be able to use basic commands like add and delete without needing to refer to the help window
after their first time using the application.
.  Should allow the user to upload images of any link:#mainstream-image-format[mainstream image format].
.  link:#hash-string[Hash String] of the users personal contact information should only be made up of alphanumeric
characters.
.  Should update the map automatically when the user changes their starting location.

{More to be added}

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...
