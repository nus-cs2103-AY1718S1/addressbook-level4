= iConnect - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-W09-B3/main/tree/master

By: `Team W09-B03`      Since: `Sep 2017`      Licence: `MIT`

== Introduction

iConnect is a one-stop student networking application. We aim to ease the job as a university student. Due to the ever-increasing workload, it has become a challenge to keep track of various school commitments while maintaining relationships with peers.With iConnect, missing schedules and losing contact with friends will be a thing of the past.

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 2.1.1 : Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 2.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 2.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 2.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagram.png[width="800"]
_Figure 2.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 2.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 2.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 2.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 2.3.1 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagram.png[width="800"]
_Figure 2.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagram.png[width="800"]
_Figure 2.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::findmech[]
=== Enhanced Find mechanism

The enhanced version of find mechanism is facilitated by the `AddressBookParser`, which resides inside `LogicManager`. It allows the users to search for person(s) by substrings of multiple different attributes (e.g. `Name`, `Phone`, `Email`, `Address`), which the case is insensitive for `Name`, `Email` and `Address` attributes.

Users can only do searching by `Name`, `Phone`, `Email` or `Address`. They are not allowed to search by `Tag`. Instead, they can search for person(s) by tags using `t-find` command.

The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

When the users are using the find command, they are required to provided at least one keyword for any available attribute. Keywords of the same attribute need to be grouped together with a prefix (e.g. `n/`, `p/`, `e/`, `a/`). In this case, each prefix is allowed to appear at most once.

During the implementation, `FindCommandParser` class splits the keywords of different attributes by searching for the location of the prefixes, and store the keywords into separate ArrayLists. As a `NameContainsKeywordsPredicate` needs to be passed to `FindCommand` class, all the keywords from the ArrayLists are added to the predicate in order with each prefix added at front for separation.

For example, the parser for name keywords is implemented this way:
[source,java]
----
int indexOfName = trimmedArgs.indexOf(PREFIX_NAME.getPrefix());

if (indexOfName != -1) {
    int index = 0;
    for (int i = 0; i < attributeIndexArray.length; i++) {
        if (attributeIndexArray[i] == indexOfName) {
            index = i;
            break;
        }
    }
    trimmedNames = trimmedArgs.substring(indexOfName + 2, attributeIndexArray[index + 1]).trim();
}

List<String> keyWordsToSearch = new ArrayList<>();

if (trimmedNames != null) {
    String[] nameKeywords = trimmedNames.split(" ");
    keyWordsToSearch.add(PREFIX_NAME.getPrefix());
    for (int i = 0; i < nameKeywords.length; i++) {
        keyWordsToSearch.add(nameKeywords[i]);
    }
}

NameContainsKeywordsPredicate predicate = new NameContainsKeywordsPredicate(keyWordsToSearch);
----

When the `FindCommand` class is executing, the keywords are taken out from the predicate and stored into separate ArrayLists again by distinguishing the prefixes stored in front of each type of keywords. The reason we do this twice is because we want to keep the consistency of all the command classes instead of changing the parameter type passed into `FindCommand` class to a list of ArrayLists. Then the person(s) can be searched separately by different attributes. For each attribute, every keyword is taken out and compared to the corresponding details of all the persons in the list. Once the keyword is matched to any substring of the detail of a person, then the person's name will be stored into an ArrayList `namesToSearch`. After searching all the keywords, a name list with persons with details matching at least one keyword is obtained and passed to `updateFilteredPersonList` method. Finally, the person list is updated and shown on the user interface.

For example, searching for name keywords is implemented this way:
[source,java]
----
for (int i = 0; i < model.getAddressBook().getPersonList().size(); i++) {
    nameList.add(model.getAddressBook().getPersonList().get(i).getName().toString().toLowerCase());
}
for (int i = 0; i < nameKeywords.size(); i++) {
    for (int j = 0; j < nameList.size(); j++) {
        if (nameList.get(j).contains(nameKeywords.get(i).toLowerCase())) {
            matchedNames.add(nameList.get(j));
        }
    }
}

if (namesMatched != null) {
    namesToSearch.addAll(matchedNames);
}

NameContainsKeywordsPredicate updatedPredicate = new NameContainsKeywordsPredicate(namesToSearch);
model.updateFilteredPersonList(updatedPredicate);
----

The following sequence diagram shows how the find command works:

image::FindCommandSequenceDiagram.png[width="800"]

[NOTE]
If no argument is provided by users after the command word, an invalid format `Exception` will be thrown.


[NOTE]
If no prefix is found inside the argument, then an invalid format `Exception` will be thrown.


[NOTE]
If some dummy values are found before the first prefix and after the command word, then an invalid format `Exception` will be thrown.


[NOTE]
If no keywords are provided by user after a prefix, then an invalid format `Exception` will be thrown.


[NOTE]
If more than one same prefix is provided by user, then the person list will be searched only by keywords behind the first prefix.

==== Design Considerations

**Aspect:** Find person by `Address` keyword +
**Alternative 1 (current choice):** Find person by a single `Address` keyword +
**Pros:** We will not need to separate multiple addresses since it is difficult to distinguish. +
**Cons:** It is inconvenient for users to find persons from different locations. +
**Alternative 2:** Separate different addresses by a special character (e.g. `;` or `*`) +
**Pros:** Users are able to find person(s) staying at different locations. +
**Cons:** The find command becomes very long. It is hard for users to type the addresses correctly.

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +
**Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()` +
**Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** Hard for new developers to understand the template pattern. +
**Alternative 2:** Just override `execute()` +
**Pros:** Does not involve the template pattern, easier for new developers to understand. +
**Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +
**Alternative 1 (current choice):** Saves the entire address book. +
**Pros:** Easy to implement. +
**Cons:** May have performance issues in terms of memory usage. +
**Alternative 2:** Individual command knows how to undo/redo by itself. +
**Pros:** Will use less memory (e.g. for `delete`, just save the person being deleted). +
**Cons:** We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +
**Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +
**Alternative 2:** Include all commands. +
**Pros:** Might be more intuitive for the user. +
**Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +
**Alternative 1 (current choice):** Use separate stack for undo and redo +
**Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +
**Alternative 2:** Use `HistoryManager` for undo/redo +
**Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]

//tag::sortmech[]
=== Sorting Mechanism

The sorting mechanism is facilitated by `SortCommandParser` and `SortCommand`, with both classes residing in the `Logic` component of the address book. Since the address book state will be modified during the sorting process, the `sort` has to be undoable.

`SortCommandParser` takes in an argument in the form of `[PREFIX]/[ORDER]` that defines how `UniquePersonList` should be sorted, with `PREFIX` specifying the sort type and `ORDER` specifying the sort order. It first checks for validity against a regular expression. Once verified, the argument will be tokenized to identify the sort order and sort type. A `SortCommand` object is then created with the identified sort type and sort order.

The `PREFIX` can be any of the following: `n/` for sorting persons by name, `p/` for sorting persons by phone number, `e/` for sorting persons by email, `a/` for sorting persons by address and `t/` for sorting persons by the time they was first added into the address book. The `ORDER` can be either `asc` for sorting in ascending order or `dsc` for sorting in descending order. Suppose both `PREFIX` and `ORDER` are not specified, the argument will be defaulted to name in ascending order. Alternatively, suppose the `ORDER` is not specified, it will be defaulted to ascending.

Upon execution of `SortCommand`, a `Comparator<ReadOnlyPerson>` will be initialised based on the sort type and sort order it receives. A `sortPerson` function call will be made to `Model`, which propagates down to `UniquePersonList`, where the sorting of the `internalList` occurs. Since sorting of `internalList` results in the change of state to address book, `SortCommand` is to be implemented as an `UndoableCommand`.

image::LogicCommandClassDiagram_Sort.png[width="800"]

[NOTE]
Implementation of Sorting Mechanism requires both the manipulation of `Logic` and `Model` component of address book.

The following sequence diagram shows the flow of operation from the point the address book receives an input to the output of the result.

image::SortPersonSdForLogic.png[width="800"]

[NOTE]
If the list is found to be empty, an `EmptyListException` will be thrown from `UniquePersonList`. The command should be terminated without any state change, keeping the redoStack clean of changes.

==== Design Considerations

**Aspect:** Initialising of `Comparator<ReadOnlyPerson>` +
**Alternative 1 (current choice):** Initialise in `SortCommand` +
**Pros:** Clear separation of concerns, `SortCommandParser` to handle identifying of attribute to sort by only. +
**Cons:** Hard for new developers to follow as other commands like `AddCommand` handles object creation in its parser. +
**Alternative 2: ** Initialise in `UniquePersonList` +
**Pros:** Straightforward as initialises the `Comparator` where it is used. +
**Cons:** `UniquePersonList` is at a lower level and should only handle a minimal set of `Person` related operations, and not logical operations like string matching. +

---

**Aspect:** Sorting by multiple attribute +
**Alternative 1 (current choice):** Only allows sorting by single attribute +
**Pros:** Fast and arguments to input is straightforward. +
**Cons:** Unable to have fine grain control of how list should appear. +
**Alternative 2:** Allow sorting by multiple attribute +
**Pros:** Enables fine grain control of how list should appear. +
**Cons:** Not necessary as effect is only obvious when contact list is long and has multiple common names. As target audience for iConnect are students, contact list will not be more than few thousand contacts long. +

---

**Aspect:** Justification for sorting contacts by time added +
**Alternative 1 (current choice):** Allows sorting by time added +
**Pros:** iConnect is design to be an all-in-one scheduling app where it is left open for extended period of time for students to check schedule. Previous implementations required user to exit and relaunch the application for viewing contacts in chronological order again. By allowing sorting by time added, user are also able to toggle to see recently added contacts first. +
**Cons:** Extra attribute has to be added to each user. +
**Alternative 2:** Not implementing sorting by time added +
**Pros:** Can be achieved by restarting app. +
**Cons:** Requires restarting of app which waste time and processing resources when list is long. +
//end::sortmech[]

// tag::tagadd[]
=== Adding a tag to multiple people

Adding a tag to multiple people is facilitated by `TagAddCommand`, which extends `UndoableCommand`, it supports undoing and redoing of commands that modifies the state of the address book.

TagAddCommand is implemented in this way:
[source,java]
----
public class TagAddCommand extends UndoableCommand {
@Override
    public CommandResult executeUndoableCommand() throws CommandException {
        // ... TagAddCommand logic ...
    }
}
----

For example, the user input might be `t-add 1 2 3 college friend`.
After the command word `t-add` is parsed at the `AddresBookParser`, the remaining user input(indices in the list, tag to add), in the example `t-add 1 2 3 college friend`, will be passed to and parsed by `TagAddCommandParser`.
Different from the previous limitation on the choice of word for `tag`, which is `Alnum`, we allow multiple words `tagName` as well, such as `college friend`.
The change of `tagName` format requires a new algorithm for parsing in the `TagAddCommandParser`.
The key is to differentiate between indices and tagName. The parser algorithm would first split the input string into parts by space as delimiter. +
It would then determine whether a part is a word or a number, the parser keeps track of the last recognized number. After processing the entire user input, the parser would treat all parts after the last recognized number as indices and those after it as `tagName`.
In this case, as `3` is the last part that is numeric, `1 2 3` is treated as indices and `college friend` is treated as `tagName`. +
The `TagAddCommandParser` returns `TagAddCommand` after execution, which will be further processed by `logic` component.

TagAddCommandParser is implemented in this way:
[source,java]
----
public class TagAddCommandParser implements Parser<TagAddCommand> {

    public TagAddCommand parse(String args) throws ParseException {
        // ... TagAddCommandParser logic ...
    }
}
----

==== Design Considerations

**Aspect:** Implementation of adding a tag to person(s) by indices +
**Alternative 1 (current choice):** Add a new Command class `TagAddCommand` +
**Pros:** Having a separate command for adding a tag is consistent with a series of tag related operations we designed to have. We can implements `UndoableCommand` Abstract Class, so that we have undo/redo functionality +
**Cons:** Have to add in a new Command class and the corresponding parser class +
**Alternative 2:** Rewrite EditCommand class +
**Pros:** We only need to change a small part of code and the undo/redo functionality can be preserved +
**Cons:** The current `EditCommand` only enables the user to edit one person at a time, which makes adding a tag to multiple contacts tedious.

---

**Aspect:** Implementation of parsing a TagAddCommand +
**Alternative 1 (current choice):** Add a new Parser class `TagAddCommandParser` +
**Pros:** We can design the input format for TagAddCommand and customize the parser +
**Cons:** Have to add in a new Parser class +
**Alternative 2:** Rewrite EditCommandParser class +
**Pros:** We only need to change a small part of code +
**Cons:** User input is restricted by the EditCommand input format.

---

**Aspect:** Whether to accept user input that has partially invalid indices +
**Alternative 1 (current choice):** Do not accept +
**Pros:** Easy to implement +
**Cons:** User have to type in the valid indices again +
**Alternative 2:** Ignore the invalid indices +
**Pros:** It is efficient for the user +
**Cons:** Difficult to implement.

=== Improvements on DeleteCommand

We have improved the delete command to let it be able to delete by multiple indexes or a name with prefix. The reason why we do this is to improve the efficiency to delete the contacts.The prefix for deleting by name is `n/`. The prefix for deleting by indexes is `I/`.

The way we implemented this is to change the DeleteCommandParser and DeleteCommand.

As for the DeleteCommandParser, we check whether there is the prefix we want in the userInput. Once the prefix is identified, if it is a `n/`, it will directly return back the parameters to DeleteCommand. If it is a `I/`, the parameters will be parsed by ParserUtil and return back the results to DeleteCommand.

As for the DeleteCommand, it can deal with two kinds of parameters: a list of indexes or a name string. If it is a list of indexes, the DeleteCommand will check whether the indexes are within the size of all persons and assert command failure if there is an illegal index. If it is a name string, the DeleteCommand will assert command failure when there is no such person in the list with name given and when there are multiple persons with the same name given.

[NOTE]
If the parameter doesn't start with correct prefix, then the command can't identify what kind of input it deals with, and a `ParseException` will be thrown when parsing.

[NOTE]
If the parameter contains illegal values or nothing after the prefix, the the command can't identify the target person, and a `ParseException` will be thrown when parsing.

[NOTE]
If the parameter is index and it is out of bound of person list, then the command can't find the person to delete, and a `CommandException` will be thrown when processsing.

[NOTE]
If the parameter is name and there is no person with such name in the list, then the command can't find the person to delete, and a `CommandException` will be thrown when processsing.

Moreover, if there is more than one person in the list with the name give, then the command don't know which one ot delete. It will show all the person with same name in GUI and remind the user to choose one to delete.


==== Design Considerations

**Aspect:**  Implementation of `DeleteCommandParser` +
**Alternative 1 (current choice):**  Add a prefix after the command word to distinguish between delete by name or indexes. +
**Pros:**  It is more convenient to identify the type of input to deal with. +
**Cons:**  It is less convenient for users to type in the prefix. +
**Alternative 2:** Use the type of first input word after command word to differentiate. +
**Pros:**  It is more convenient for the users to type. +
**Cons:** It is harder for the developer to find the type if the users give a name with all numbers to a contact.

---

**Aspect:**  How to deal with multiple persons with same name condition +
**Alternative 1 (current choice):**  Do not delete the persons and show all the persons with the same target name on the list. Remind the user to decide which one to delete. +
**Pros:**  It considers more about the users. Try to ensure the target is the person who the users want to delete. +
**Cons:**  It cost users more time to delete a person if they don't know the index of the target. +
**Alternative 2:** Delete the first person with the name in the list and show it to user. +
**Pros:**  It cost users less time to delete a person if they know the sequence of the persons with the same name. +
**Cons:** It is hard to guarantee the right person is deleted. The user may need to redo to fix it.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).



== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.6.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Suggested Programming Tasks to Get Started

Suggested path for new programmers:

1. First, add small local-impact (i.e. the impact of the change does not go beyond the component) enhancements to one component at a time. Some suggestions are given in this section link:#improving-each-component[Improving a Component].

2. Next, add a feature that touches multiple components to learn how to implement an end-to-end feature across all components. The section link:#creating-a-new-command-code-remark-code[Creating a new command: `remark`] explains how to go about adding such a feature.

=== Improving each component

Each individual exercise in this section is component-based (i.e. you would not need to modify the other components to get it to work).

[discrete]
==== `Logic` component

[TIP]
Do take a look at the link:#logic-component[Design: Logic Component] section before attempting to modify the `Logic` component.

. Add a shorthand equivalent alias for each of the individual commands. For example, besides typing `clear`, the user can also type `c` to remove all persons in the list.
+
****
* Hints
** Just like we store each individual command word constant `COMMAND_WORD` inside `*Command.java` (e.g.  link:{repoURL}/src/main/java/seedu/address/logic/commands/FindCommand.java[`FindCommand#COMMAND_WORD`], link:{repoURL}/src/main/java/seedu/address/logic/commands/DeleteCommand.java[`DeleteCommand#COMMAND_WORD`]), you need a new constant for aliases as well (e.g. `FindCommand#COMMAND_ALIAS`).
** link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] is responsible for analyzing command words.
* Solution
** Modify the switch statement in link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser#parseCommand(String)`] such that both the proper command word and alias can be used to execute the same intended command.
** See this https://github.com/se-edu/addressbook-level4/pull/590/files[PR] for the full solution.
****

[discrete]
==== `Model` component

[TIP]
Do take a look at the link:#model-component[Design: Model Component] section before attempting to modify the `Model` component.

. Add a `removeTag(Tag)` method. The specified tag will be removed from everyone in the address book.
+
****
* Hints
** The link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model`] API needs to be updated.
**  Find out which of the existing API methods in  link:{repoURL}/src/main/java/seedu/address/model/AddressBook.java[`AddressBook`] and link:{repoURL}/src/main/java/seedu/address/model/person/Person.java[`Person`] classes can be used to implement the tag removal logic. link:{repoURL}/src/main/java/seedu/address/model/AddressBook.java[`AddressBook`] allows you to update a person, and link:{repoURL}/src/main/java/seedu/address/model/person/Person.java[`Person`] allows you to update the tags.
* Solution
** Add the implementation of `deleteTag(Tag)` method in link:{repoURL}/src/main/java/seedu/address/model/ModelManager.java[`ModelManager`]. Loop through each person, and remove the `tag` from each person.
** See this https://github.com/se-edu/addressbook-level4/pull/591/files[PR] for the full solution.
****

[discrete]
==== `Ui` component

[TIP]
Do take a look at the link:#ui-component[Design: UI Component] section before attempting to modify the `UI` component.

. Use different colors for different tags inside person cards. For example, `friends` tags can be all in grey, and `colleagues` tags can be all in red.
+
**Before**
+
image::getting-started-ui-tag-before.png[width="300"]
+
**After**
+
image::getting-started-ui-tag-after.png[width="300"]
+
****
* Hints
** The tag labels are created inside link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard#initTags(ReadOnlyPerson)`] (`new Label(tag.tagName)`). https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Label.html[JavaFX's `Label` class] allows you to modify the style of each Label, such as changing its color.
** Use the .css attribute `-fx-background-color` to add a color.
* Solution
** See this https://github.com/se-edu/addressbook-level4/pull/592/files[PR] for the full solution.
****

. Modify link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] such that link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay`] can show a different style on error (currently it shows the same regardless of errors).
+
**Before**
+
image::getting-started-ui-result-before.png[width="200"]
+
**After**
+
image::getting-started-ui-result-after.png[width="200"]
+
****
* Hints
** link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] is raised by link:{repoURL}/src/main/java/seedu/address/ui/CommandBox.java[`CommandBox`] which also knows whether the result is a success or failure, and is caught by link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay`] which is where we want to change the style to.
** Refer to link:{repoURL}/src/main/java/seedu/address/ui/CommandBox.java[`CommandBox`] for an example on how to display an error.
* Solution
** Modify link:{repoURL}/src/main/java/seedu/address/commons/events/ui/NewResultAvailableEvent.java[`NewResultAvailableEvent`] 's constructor so that users of the event can indicate whether an error has occurred.
** Modify link:{repoURL}/src/main/java/seedu/address/ui/ResultDisplay.java[`ResultDisplay#handleNewResultAvailableEvent(event)`] to react to this event appropriately.
** See this https://github.com/se-edu/addressbook-level4/pull/593/files[PR] for the full solution.
****

. Modify the link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] to show the total number of people in the address book.
+
**Before**
+
image::getting-started-ui-status-before.png[width="500"]
+
**After**
+
image::getting-started-ui-status-after.png[width="500"]
+
****
* Hints
** link:{repoURL}/src/main/resources/view/StatusBarFooter.fxml[`StatusBarFooter.fxml`] will need a new `StatusBar`. Be sure to set the `GridPane.columnIndex` properly for each `StatusBar` to avoid misalignment!
** link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] needs to initialize the status bar on application start, and to update it accordingly whenever the address book is updated.
* Solution
** Modify the constructor of link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter`] to take in the number of persons when the application just started.
** Use link:{repoURL}/src/main/java/seedu/address/ui/StatusBarFooter.java[`StatusBarFooter#handleAddressBookChangedEvent(AddressBookChangedEvent)`] to update the number of persons whenever there are new changes to the addressbook.
** See this https://github.com/se-edu/addressbook-level4/pull/596/files[PR] for the full solution.
****

[discrete]
==== `Storage` component

[TIP]
Do take a look at the link:#storage-component[Design: Storage Component] section before attempting to modify the `Storage` component.

. Add a new method `backupAddressBook(ReadOnlyAddressBook)`, so that the address book can be saved in a fixed temporary location.
+
****
* Hint
** Add the API method in link:{repoURL}/src/main/java/seedu/address/storage/AddressBookStorage.java[`AddressBookStorage`] interface.
** Implement the logic in link:{repoURL}/src/main/java/seedu/address/storage/StorageManager.java[`StorageManager`] class.
* Solution
** See this https://github.com/se-edu/addressbook-level4/pull/594/files[PR] for the full solution.
****

=== Creating a new command: `remark`

By creating this command, you will get a chance to learn how to implement a feature end-to-end, touching all major components of the app.

==== Description
Edits the remark for a person specified in the `INDEX`. +
Format: `remark INDEX r/[REMARK]`

Examples:

* `remark 1 r/Likes to drink coffee.` +
Edits the remark for the first person to `Likes to drink coffee.`
* `remark 1 r/` +
Removes the remark for the first person.

==== Step-by-step Instructions

===== [Step 1] Logic: Teach the app to accept 'remark' which does nothing
Let's start by teaching the application how to parse a `remark` command. We will add the logic of `remark` later.

**Main:**

. Add a `RemarkCommand` that extends link:{repoURL}/src/main/java/seedu/address/logic/commands/UndoableCommand.java[`UndoableCommand`]. Upon execution, it should just throw an `Exception`.
. Modify link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] to accept a `RemarkCommand`.

**Tests:**

. Add `RemarkCommandTest` that tests that `executeUndoableCommand()` throws an Exception.
. Add new test method to link:{repoURL}/src/test/java/seedu/address/logic/parser/AddressBookParserTest.java[`AddressBookParserTest`], which tests that typing "remark" returns an instance of `RemarkCommand`.

===== [Step 2] Logic: Teach the app to accept 'remark' arguments
Let's teach the application to parse arguments that our `remark` command will accept. E.g. `1 r/Likes to drink coffee.`

**Main:**

. Modify `RemarkCommand` to take in an `Index` and `String` and print those two parameters as the error message.
. Add `RemarkCommandParser` that knows how to parse two arguments, one index and one with prefix 'r/'.
. Modify link:{repoURL}/src/main/java/seedu/address/logic/parser/AddressBookParser.java[`AddressBookParser`] to use the newly implemented `RemarkCommandParser`.

**Tests:**

. Modify `RemarkCommandTest` to test the `RemarkCommand#equals()` method.
. Add `RemarkCommandParserTest` that tests different boundary values
for `RemarkCommandParser`.
. Modify link:{repoURL}/src/test/java/seedu/address/logic/parser/AddressBookParserTest.java[`AddressBookParserTest`] to test that the correct command is generated according to the user input.

===== [Step 3] Ui: Add a placeholder for remark in `PersonCard`
Let's add a placeholder on all our link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] s to display a remark for each person later.

**Main:**

. Add a `Label` with any random text inside link:{repoURL}/src/main/resources/view/PersonListCard.fxml[`PersonListCard.fxml`].
. Add FXML annotation in link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] to tie the variable to the actual label.

**Tests:**

. Modify link:{repoURL}/src/test/java/guitests/guihandles/PersonCardHandle.java[`PersonCardHandle`] so that future tests can read the contents of the remark label.

===== [Step 4] Model: Add `Remark` class
We have to properly encapsulate the remark in our link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`] class. Instead of just using a `String`, let's follow the conventional class structure that the codebase already uses by adding a `Remark` class.

**Main:**

. Add `Remark` to model component (you can copy from link:{repoURL}/src/main/java/seedu/address/model/person/Address.java[`Address`], remove the regex and change the names accordingly).
. Modify `RemarkCommand` to now take in a `Remark` instead of a `String`.

**Tests:**

. Add test for `Remark`, to test the `Remark#equals()` method.

===== [Step 5] Model: Modify `ReadOnlyPerson` to support a `Remark` field
Now we have the `Remark` class, we need to actually use it inside link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`].

**Main:**

. Add three methods `setRemark(Remark)`, `getRemark()` and `remarkProperty()`. Be sure to implement these newly created methods in link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`Person`], which implements the link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`] interface.
. You may assume that the user will not be able to use the `add` and `edit` commands to modify the remarks field (i.e. the person will be created without a remark).
. Modify link:{repoURL}/src/main/java/seedu/address/model/util/SampleDataUtil.java/[`SampleDataUtil`] to add remarks for the sample data (delete your `addressBook.xml` so that the application will load the sample data when you launch it.)

===== [Step 6] Storage: Add `Remark` field to `XmlAdaptedPerson` class
We now have `Remark` s for `Person` s, but they will be gone when we exit the application. Let's modify link:{repoURL}/src/main/java/seedu/address/storage/XmlAdaptedPerson.java[`XmlAdaptedPerson`] to include a `Remark` field so that it will be saved.

**Main:**

. Add a new Xml field for `Remark`.
. Be sure to modify the logic of the constructor and `toModelType()`, which handles the conversion to/from  link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`ReadOnlyPerson`].

**Tests:**

. Fix `validAddressBook.xml` such that the XML tests will not fail due to a missing `<remark>` element.

===== [Step 7] Ui: Connect `Remark` field to `PersonCard`
Our remark label in link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`] is still a placeholder. Let's bring it to life by binding it with the actual `remark` field.

**Main:**

. Modify link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard#bindListeners()`] to add the binding for `remark`.

**Tests:**

. Modify link:{repoURL}/src/test/java/seedu/address/ui/testutil/GuiTestAssert.java[`GuiTestAssert#assertCardDisplaysPerson(...)`] so that it will compare the remark label.
. In link:{repoURL}/src/test/java/seedu/address/ui/PersonCardTest.java[`PersonCardTest`], call `personWithTags.setRemark(ALICE.getRemark())` to test that changes in the link:{repoURL}/src/main/java/seedu/address/model/person/ReadOnlyPerson.java[`Person`] 's remark correctly updates the corresponding link:{repoURL}/src/main/java/seedu/address/ui/PersonCard.java[`PersonCard`].

===== [Step 8] Logic: Implement `RemarkCommand#execute()` logic
We now have everything set up... but we still can't modify the remarks. Let's finish it up by adding in actual logic for our `remark` command.

**Main:**

. Replace the logic in `RemarkCommand#execute()` (that currently just throws an `Exception`), with the actual logic to modify the remarks of a person.

**Tests:**

. Update `RemarkCommandTest` to test that the `execute()` logic works.

==== Full Solution

See this https://github.com/se-edu/addressbook-level4/pull/599[PR] for the step-by-step solution.

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |organised user |sort contacts by different attributes, ascending/descending order |look for specific contact easily

|`* * *` |organised user |classify my contacts by a tag |find the relevant people under a tag quickly

|`* * *` |desperate user |find contact by substring of name |find a person even if I forget the exact contact name

|`* * *` |forgetful user |find specific contacts by attributes other than name |find out the contact’s name

|`* * *` |lazy user |launch commands by keying in shortcuts |save time

|`* * *` |organised user |have different colors for tag to specify its priority |have a finer classification

|`* * *` |logical user |sort contacts chronologically by either ascending or descending order |keep track of my records

|`* * *` |forgetful user |type in alias of commands |choose not to remember specific commands

|`* * *` |lazy user |delete multiple user by index |perform batch deletion

|`* * *` |lazy user |delete user by name |perform faster deletion without finding the index

|`* * *` |worried user |export my contact list to a backup file (separate from data/addressbook.xml) |restore my contact list in case corruption happens

|`* *` |particular user |change the color theme/background image of the product |have a nice visual experience

|`* *` |paranoid user |hide private contact details by default |minimize chance of someone else seeing them by accident

|`* *` |power user |launch a shell version of the product |operate without the clutter

|`* *` |organised user |record schedules with my contacts (like a calendar) | keep track of my upcoming events

|`* *` |dedicated user |see my contact’s address on google map |meet them for project

|`* *` |power user |copy contact details to clipboard | have quick access to contact details in plaintext

|`* *` |sociable user |store social media information for contacts |keep track

|`* *` |friendly user |find out the route from one contact’s address to my home address |know the way to my contact’s home

|`* *` |frequent user |synchronize contact information with all devices |choose not to update one by one

|`* *` |forgetful user |input events based on natural language |add in events easily

|`* *` |careless user |specify number of times to undo/redo with in input parameter |save time

|`* *` |careless user |get a list of contact that I removed (like a Recycle bin) |recover the accidentally deleted ones

|`* *` |paranoid user |remove all contacts permanently from the deleted contact list |clear my records

|`*` |power user |exclude words in my searches |filter my search result

|`*` |efficient user |send an email from the program (launch the system’s default mailto:) |do something with the contacts

|`*` |sociable user |customize the URL of my contact (instead of the default google page) |be up to date with how my contacts are doing

|`*` |friendly user |get notification on contacts’ birthdays |send birthday wishes

|`*` |forgetful user |get notification on upcoming events |choose not to remember mentally

|`*` |forgetful user |store standalone events (does not involve anyone in the contact list) |keep track of my schedule

|`*` |friendly user |tag the hobbies of contacts |get closer to them

|`*` |lazy user |get contact details by scanning QR code |choose not to type manually

|`*` |friendly user |find date matches |meet new friends

|`*` |sociable user |share events online for people to see |people can join me
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `AddressBook` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Add contact

*MSS*

1.  User input command to add contact: add n/[NAME] p/[PHONE] e/[EMAIL] a/[ADDRESS]
2.  Address book stores contact and outputs success message

+
Use case ends.

*Extensions*

[none]
* 2a. User enters incomplete contact information with missing fields
+
[none]
** 2a1. Address book shows error message
+
Use case ends.
+
Use case ends.
[none]
* 2b. Similar contact already exist in Address Book
+
[none]
** 2b1. Address book shows error message
+
Use case ends.

[discrete]
=== Use case: Edit contact

*MSS*

1.  User input command to edit contact: edit INDEX n/[NAME] p/[PHONE] e/[EMAIL] a/[ADDRESS]
2.  Address book edits relevant contact details and outputs success message
+
Use case ends.

*Extensions*

[none]
* 2a. Invalid index inputted
+
[none]
** 2a1. Address book shows error message
+
Use case ends.

* 2b. No attributes was inputted
+
[none]
** 2b1. Address book shows error message
+
Use case ends.

[discrete]
=== Use case: Delete contact

*MSS*

1.  User input command to delete contact: delete INDEX
2.  Address delete contact from list and outputs success message
+
Use case ends.

*Extensions*

[none]
* 2a. Invalid index inputted
+
[none]
** 2a1. Address book shows error message
+
Use case ends.

[discrete]
=== Use case: Find contact by keywords

*MSS*

1.  User input command to find contacts: find [n/NAMES] [p/PHONES] [e/EMAILS] [a/ADDRESS]
2.  Address book shows a list of contacts with at least one of the keywords provided
+
Use case ends.

*Extensions*

[none]
* 2a. No arguments are provided after the command word
+
[none]
** 2a1. Address book shows user an incorrect input format message
+
Use case ends.

* 2b. No keywords are provided after a prefix
+
[none]
** 2b1. Address book shows user an incorrect input format message
+
Use case ends.

* 2c. Dummy values are provided before the first prefix
+
[none]
** 2c1. Address book shows user an incorrect input format message
+
Use case ends.

* 2d. User enters multiple same prefixes
+
[none]
** 2d1. Address book only shows contacts provided by keywords after the first prefix and ignores the rest
+
Use case ends.

* 2e. No contacts found by the given keywords
[none]
** 2e1. Address book shows an empty list message
+
Use case ends.

[discrete]
=== Use case: Sort contact list

*MSS*

1.  User input command to sort contacts: sort [PREFIX]/[ORDER]
2.  Address book sorts contacts and output sorted list
+
Use case ends.

*Extensions*

[none]
* 2a. No arguments inputted
+
[none]
** 2a1. Address book sorts contacts by name in ascending order and output sorted list
+
Use case ends.

[none]
* 2a. No sort order inputted
+
[none]
** 2a1. Address book sort by inputted attribute in ascending order and output sorted list
+
Use case ends.

[none]
* 2a. The address book is empty
+
[none]
** 2a1. Address book shows an empty list message
+
Use case ends.

* 2a. Invalid arguments inputted
+
[none]
** 2a1. Address book shows an error message
+
Use case ends.

== Non Functional Requirements

.  Address book should have restricted access.
.  System should responds within 2 seconds.
.  Address book source should be open sourced.
.  Should work on both 32bit and 64bit.
.  Instructions should be in logical abbreviations of their functions.
.  Users are able to type short commands (less than 80 characters) to achieve what they want.
.  The address book product should to free to all users.
.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[private-contact-detail]]
Private contact detail

....
A contact detail that is not meant to be shared with others
....

[[Alnum]]
Alnum

....
A regular expression that matches all numbers and letters
....

[[tagName]]
tagName

....
Name of a tag
....

[[index]]
index

....
A running number used to label the contacts, often inserted after a command to serve as contact selection
....

[[recycle-list]]
recycle list

....
A list of deleted contacts
....

[[AddressBook.xml]]
AddressBook.xml

....
The file that the contact list is stored to, located in the ‘data’ folder
....
