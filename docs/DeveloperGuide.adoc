= H.M.U - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-F10-B2/main

By: `CS2103-F10-B2`      Since: `Sep 2017`      Licence: `MIT`

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 2.1.1 : Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 2.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 2.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 2.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagram.png[width="800"]
_Figure 2.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 2.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 2.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 2.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 2.3.1 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagram.png[width="800"]
_Figure 2.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagram.png[width="800"]
_Figure 2.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]

// tag::meetingLocation[]
=======

// tag::locate[]
=== Best Meeting Location Mechanism
image::mrtMapImage.png[width="800"]
TheBest Meeting Location Mechanism is an algorithm to compute the best mrt
station for the user to meet. The "best mrt station" is defined as the mrt station
that requires the least total travelling time among all the users. As shown in the
image above, MacPherson is the "best mrt station". The other non-grey circle (that
doesn't have name indicated) are mrt stations where the users lives. The size of that
circle reflects the number of people actually living there or near there.

The primary logic for getting the best meeting location is stored with the
MrtMapLogic.java file. This method uses Dijkstra's algorithm to find the minimum
travelling time to every mrt stations for every users. The total travelling time for
a particular mrt station is the summation of all the user's least travelling time
for the original location to that location. The mrt station that has the least
total travelling time will be declared as the "best mrt station" for meeting.

The travelling time computed reflects the actual travelling time if a person is to
actually travel physically from one station in singapore to another. Note that only
Singapore's currently operating Mrt Stations are included. The time taken for an
individual to transfer a station is reflected as 5 minutes, which is accurate considering
that a person need to walk to the other mrt line, then wait for the train to arrive.

The information regarding the mrt station and travelling time is hard coded within
the java class itself to avoid any other class from altering any of that information.
Another reason for storing the information within the java class is because the class
that visualises the MRT MAP (shown above) requires the exact same station to work.
As shown in the image, the mrt map is roughtly similar with that found in that
standard Singapore map. This is made possible with some of the coordinate of the
mrt station within the canvass itself being hard coded.

// end::meetingLocation[]
=======

=== Locate mechanism

The Locate Command gets the last shown list, which is the current list of persons being shown before using this command.

Locate Command only deals with the GUI part. When specified an index, it retrieves the person to be located and send a new `LocateCommandEvent` to `EventCenter`.

`BrowserPanel` takes such an event message and uses Google Map to search the person's address when receiving a LocateCommandEvent.
Commands that are not undoable are implemented this way:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {
    @Subscribe
    private void handleLocateCommandEvent(LocateCommandEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        loadLocationPage(event.getPerson());
    }
}
----

loadLocationPage adds the person's address info after the searching URL of Google map to get the URL of searching the specified person's address and loads the relevant page.

// end::locate[]
// tag::locateCon[]

==== Design Considerations


*Aspect:* Whether to truncate the string of address.

*Alternative 1 (current choice):* no.

*Pros:* Accurate and unambiguous.

*Cons:* Will generate a very complex string in the google map search column.

*Alternative 2*: Truncate the address string.

*Pros:* The text to be searched in google map column will be clear and succinct.

*Cons:* The addresses don't have a standard format so it's not feasible to get the truncated address.

// end::locateCon[]
// tag::addclearSchedule[]
=== Add/Clear Schedule Mechanism
The Add/Clear schedule mechanism supports the adding/clearing of time slots of a specific person. The command will be inherited from `UndoableCommand` so that the user can revert the adding or cleaning of schedule by mistake.

The following diagram shows the inheritance
diagram for add and clear commands:

image::person.png[width="800"]

As you can see from the diagram, `AddScheduleCommand` and `AddScheduleCommand` inherit from `UndoCommand`
just like `add` and `delete`.

Below is the sequence diagram of the `AddScheduleCommand` and `ClearScheduleCommand`.

image::addClearSchedule.png[width="800"]

Firstly, the `addSchedule/clearSchedule` command is typed into the Command Line. This starts up the `LogicManager` which
then parses the command using `AddressBookParser`. It then executes using `model`, which calls
the `AddressBook to add/clear the schedule`. It then asks the internal list inside to select the person specified
and add/clear the time slot from the schedule accordingly.

// end::addclearSchedule[]
// tag::scdconsideration[]

==== Design Considerations


*Aspect:* To use a tree or a boolean array to store the schedules.

*Alternative 1 (current choice):* use a tree.

*Pros:* Avoid converting the index to time, efficient to search.

*Cons:* Not intuitive to enhance and visualize.

*Alternative 2*: use an array.

*Pros:* Straightforward.

*Cons:* Need to link the index to the number that specifies time. Magic numbers introduced.

*Aspect:* Whether to store free time slots or busy time slots.

*Alternative 1 (current choice):* Store free time slots.

*Pros:* Easy to use, make the user feel less troublesome in adding slots.

*Cons:* Not simulating modern schedule apps' scheme.

*Alternative 2*: Store busy time slots.

*Pros:* Easy for the user to edit when he/she encounter a new event.

*Cons:* Extremely difficult for the user to initialize the schedule.

// end::scdconsideration[]
// tag::VisualizeSchedule[]
=== Visualize Schedule Mechanism
The Visualize schedule mechanism supports viewing a person's schedule.

`VisualizeCommand` inherits from `Command`
just like `list` and `find`.

Firstly, the `visualize` command is typed into the Command Line. This starts up the `LogicManager` which
then parses the command using `AddressBookParser`. It then executes using `model`, which calls
the `AddressBook to add/clear the schedule`. It then asks the internal list inside to select the person specified
and add/clear the schedule accordingly.

// end::VisualizeSchedule[]
// tag::Vconsideration[]

==== Design Considerations


*Aspect:* Whether to create a independent command to visualize the schedule

*Alternative 1 (current choice):* Yes.

*Pros:* Gives instant support and feedback once the user do a schedule modification

*Cons:* Can be substituted by the arrange command when inputing 1 person.

*Alternative 2*: No.

*Pros:* Save codes.

*Cons:* Not user friendly.

// end::Vconsideration[]
// tag::arrangeMeeting[]
=== Arrange Meeting Mechanism
The Arrange Meeting mechanism supports looking for the common free time slots of a list of people.

`ArrangeCommand` inherits from `Command`
just like `list` and `find`.


Firstly, the `arrange` command is typed into the Command Line. This starts up the `LogicManager` which
then parses the command using `AddressBookParser`. It then executes using `model`, which calls
the `AddressBook to add/clear the schedule`. It then asks the internal list inside to select the person specified
and add/clear the schedule accordingly.

// end::arrangeMeeting[]
// tag::Aconsideration[]

==== Design Considerations

*Aspect:* Whether to store free time slots or busy time slots.

*Alternative 1 (current choice):* Store free time slots.

*Pros:* Easy to use, make the user feel less troublesome in adding slots.

*Cons:* Not simulating modern schedule apps' scheme.

*Alternative 2*: Store busy time slots.

*Pros:* Easy for the user to edit when he/she encounter a new event.

*Cons:* Extremely difficult for the user to initialize the schedule.

*Aspect:* Whether to specify the number of people in the meeting

*Alternative 1 (current choice):* No.

*Pros:* Easier for the user to input.

*Cons:* Need parsing the string. May Render unexpected bugs.

*Alternative 2*: Yes

*Pros:* Safer.

*Cons:* Difficult to implement and to use as the number of people to arrange is unspecified.


// end::Aconsideration[]
// tag::changepw[]
=== Change Password Mechanism
The Change Password mechanism resides inside `LogicManager`.
It supports the changing of password which requires the previous username
and password. The command will not be inherited from `UndoableCommand`. This
is due to security reasons and users will not be able to `undo` their password
change. Users have to change the password again through the command `changepw`.

As `ChangePasswordCommand` does not inherit from `UndoableCommand`, it will
inherit from `Command` instead. The following diagram shows the inheritance
diagram for commands:

image::ChangePasswordCommandInheritance.png[width="800"]

As you can see from the diagram, `ChangePasswordCommand` does not inherit from `UndoableCommand`
just like `find` and `undo`.

Below is the sequence diagram of the `ChangePasswordCommand`.

image::ChangePasswordSequenceDiagram.png[width="800"]

Firstly, the `changepw` command is typed into the Command Line. This starts up the `LogicManager` which
then parses the command using `AddressBookParser`. It then executes using `model`, which retrieves
the `UserPrefs`. It then changes the password in the `preferences.json` file after hashing it using
SHA-256 in the `changePassword()` method.

// end::changepw[]

// tag::pwconsideration[]
==== Design Considerations


*Aspect:* To hash or not to hash passwords

*Alternative 1 (current choice):* Hash the password

*Pros:* Added level of security as password is hashed.

*Cons:* Slightly more troublesome to implement hashing algorithm.

*Alternative 2*: Don't hash the password

*Pros:* Straightforward

*Cons:* Less security

*Aspect:* To include username or not to include in `changepw`

*Alternative 1 (current choice):* Require correct username to change password

*Pros:* For future development, where many users can use a single app using different
usernames.

*Cons:* User might forget username.

*Alternative 2*: Does not require username to change password

*Pros:* Very straightforward (`changepw oldpassword newpassword`)

*Cons:* Might have to change a lot of components if want to allow users to have multiple accounts in
the later part of the project.


// end::pwconsideration[]


// tag::changeuser[]
=== Change Username Mechanism
The Change Username mechanism resides inside `LogicManager`.
It supports the changing of username which requires the previous username
and password. The command will not be inherited from `UndoableCommand`. This
is due to security reasons and users will not be able to `undo` their username
change. Users have to change the password again through the command `changeuser`.

As `ChangeUsernameCommand` does not inherit from `UndoableCommand`, it will
inherit from `Command` instead.

Firstly, the `changeuser` command is typed into the Command Line. This starts up the `LogicManager` which
then parses the command using `AddressBookParser`. It then executes using `model`, which retrieves
the `UserPrefs`. It then changes the username in the `preferences.json` file. Unlike ChangePasswordCommand,
the username is not hased using SHA-256.

// end::changeuser[]

// tag::changeuserconsiderations[]

==== Design Considerations

*Aspect:* To have username or not to have username

*Alternative 1 (current choice):* Have username

*Pros:* In view of future developments, users will be able to use different accounts.
More security as user needs both `username` and `password` to log in.

*Cons:* Users need to remember more information (For future development: Implement a hint feature whereby it
gives users hints in case they forget their username or password)

*Alternative 2*: Don't have username

*Pros:* Straightforward

*Cons:* Less security

// end::changeuserconsiderations[]

// tag::createDefaultAcc[]

=== Create Default Account Mechanism
The Create Default Account mechanism resides inside `LogicManager`.
It supports the creation of an account of username and password, `admin`. The command will not be inherited from
`UndoableCommand`. This is due to security reasons and users will not be able to `undo` their account creation.


As `CreateDefaultAccountCommand` does not inherit from `UndoableCommand`, it will
inherit from `Command` instead.

Firstly, the pre-condition to use this command is that no existing account must be in `Storage` file,
`preferences.json`. Secondly, the user have to type `createDefaultAccount` in the command line. This starts up the `LogicManager` which
then parses the command using `AddressBookParser`. It then executes using `model`, which retrieves
the `UserPrefs`. It then changes the `username` and `password` in the `preferences.json` file to `admin`. Just like
the Change Password Mechanism, the password is hashed using SHA-256.

// end::createDefaultAcc[]

// tag::createDefaultConsiderations[]

==== Design Considerations

*Aspect:* To have the feature or not

*Alternative 1 (current choice):* Have Feature

*Pros:* Cater to different kinds of users. Some users might not want to have the login feature as they do not
have important information in their H.M.U contacts. However, some users might want the login feature. Thus, at
the start, they can choose to create an account or not.

*Cons:* Feature might change in the future as we allow users to create more than 1 account.

*Alternative 2*: Do not have feature

*Pros:* None

*Cons:* Username and Password is equals to null at the start. To use the `changeuser` and `changepw` command,
the user have to key in white spaces which might not seem intuitive to use and not user-friendly.


*Aspect:* To create default username and password or allow users to key in desired username and password from the start

*Alternative 1 (current choice):* Default username and password

*Pros:* In case of the use of this command by accident, users will know the username and password as shown in
the user guide.

*Cons:* Users will have to go through 3 commands just to change the username and password. (They have to go through
`createDefaultAcc`, `changepw`, and `changeuser`)

*Alternative 2:* Allow users to create their username and password with 1 command

*Pros:* More user-friendly

*Cons:* Users who are experimenting with the new application might accidentally create an account without
their knowledge and end up locking themselves out of the application.

*Suggestions:* +
Implement forget username/password feature where users can use the command to get hints of
their username and password that they have set. +

Use a double confirm message when user uses `createDefaultAcc` command.

If implemented suggestion, `createDefaultAcc` will become `createAcc` where users can set their username
and password. (v2.0)

// end::createDefaultConsiderations[]

// tag::removeLogin[]

=== Remove Account Mechanism
The Remove Login Mechanism resides inside `LogicManager`.
It supports the removal of an account. The command will not be inherited from
`UndoableCommand`. This is due to security reasons and users will not be able to `undo` their account removal.

As `RemoveAccountCommand` does not inherit from `UndoableCommand`, it will
inherit from `Command` instead.

Firstly, the pre-condition to use this command is that there must be an existing account in `Storage` file,
`preferences.json`. Secondly, the user have to type `removeLogin` in the command line followed by
his `username` and `password`. This starts up the `LogicManager` which then parses the command
using `AddressBookParser`. It then executes using `model`, which retrieves
the `UserPrefs`. It then changes the `username` and `password` in the `preferences.json` file to `null`. In the LogicManager,
when both `username` and `password` is `null`, H.M.U will work automatically without the need to login.

// end::removeLogin[]

// tag::removeLoginConsiderations[]

==== Design Considerations

*Aspect:* To have the feature or not

*Alternative 1 (current choice):* Have Feature

*Pros:* Cater to different kinds of users. Some users might not want to have the login feature as they do not
have important information in their H.M.U contacts. However, some users might want the login feature. Thus, this
feature allows users to change their preferences to have a login at any point in time.

*Cons:* Feature might change in the future as we allow users to create more than 1 account.

*Alternative 2*: Do not have feature

*Pros:* None

*Cons:* Once account is created, users will not be able to disable the login feature.

// end::removeLoginConsiderations[]

// tag::search[]
=== Search Mechanism
The Search Mechanism is implemented mainly in the logic and model component. It allows for searches to be performed on different fields,
with 2 different types of searches to be performed on multiple fields: "AND" and "OR" search.
The command will not make any changes to the addressbook and thus does not inherit from `Undoable Command`.

The variety of search mechanisms are implemented to enable users to find their contacts easily when they have a large number of contacts in their addressbook.
This is also to get a filtered view of persons such that the command `arrange` which requires the indices of the persons is more user friendly.

The commands for the search mechanisms are as follows:

image::findRelationDiagram.png[width="800"]

As shown, there is `findByName`, which conducts an "OR" search based on the field `name`, and the same goes for every other field.
`find` however can conduct both "AND" and "OR" searches with multiple fields.

Below is a sequence diagram for the FindCommand.

image::findSeqDiagram.png[width="800"]

After the user inputs the fields he wants to search in, the logic manager evokes the `AddressbookParser` and the `FindCommandParser`,
which maps the different fields into a `FindPersonDescriptor`, which stores all the search keywords. The descriptor is passed into a `FindCommand`.
The FindCommand initialises with its `PersonContainsKeywordsPredicates`, which gets all the keywords from the descriptor.
The FindCommand is then returned to the logic manager which calls for `command.execute()`.
The FindCommand uses the model to get persons in the current view and tests all persons based on the predicate.
Accordind to the type of search and number of matches, the person(s) that fulfills the search criteria will be shown on the GUI.
Note: FindByMrt currently does not exist as it is of a lower priority (overlaps with findByAddress)

// end::search[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.6.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]

== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |

|`* * *` |user |set a schedule for my contacts |see when they are free

|`* * *` |user |find the nearest common meeting point |decide on where to meet my contacts

|`* * *` |user who does not need added security |be able to remove login requirements |access H.M.U without logging in

|`* * *` |user |delete a person |remove entries that I no longer need

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |user |search for the user based on certain keywords|find contacts easily

|`* * *` |user |know how to use the commands  |to get familiar with the app

|`* * *` |user with few contacts |sort my contacts by name |find my contacts easily by scrolling

|`* * *` |user |save my contacts both online and offline |quit the project without fear of losing my contacts

|`* * *` |user |exit the program |

|`* * *` |user |list my contacts |see all my entries

|`* * *` |user |edit my contacts |update any changes to my contacts

|`* * *` |user |see my contacts' schedule on a timetable |visualize it easily

|`* *` |user |see the contact's information when clicking on them |see it more clearly

|`* *` |user |find my contacts by MRT |find who stays at a particular location

|`* *` |user |find my contacts location on Google Maps |know how to get to the location easily

|`* *` |user |double-confirm the delete command and clear command|avoid accidental commands

|`* *` |user |view my command history |recall what changes I have made

|`* *` |user |add a photo beside my contact |associate my contact using their photos

|`* *` |user |export a contact |share the contact with someone

|`* *` |user |find all contacts with a particular tag |locate all details of the group without having to go through the entire list

|`* *` |experienced user |enter a command shortcut |save time

|`* *` |user |open the program with a keyboard shortcut |save time

|`* *` |new user |import my contacts from other existing contact lists |save time by not needing to manually add my contacts again

|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else seeing them by accident

|`* *` |user |have a backup file and a backup command |store the data to avoid accidental data loss

|`* *` |user |set up a login password |prevent someone else from looking at my contacts just by opening the application

|`* *` |user |see a network of my contacts' addresses on Google Maps |see where all my contacts live on a map

|`* *` |user |undo a command |remove any unwanted changes I might accidentally make

|`* *` |user |redo an undone command |reapply the changes that I might accidentally undo

|`* *` |user with many contacts |get the person who was searched by the user for the most times |get the info of frequent contacts easily

|`*` |user |link my contacts to social media platforms |visit my friend's profile easily

|`*` |user |customize the GUI |personalize its aesthetics to my liking

|`*` |user with many contacts |sort persons by name |locate a person easily
|=======================================================================


{More to be added}

[appendix]
== Use Cases

(For all use cases below, the *System* is the `H.M.U` and the *Actor* is the `user`, unless specified otherwise)

[discrete]

== User case: Add person

*MSS*

1. User requests to add person with the person's name, email, phone, address and mrt location
2. H.M.U adds the person

Use case ends.

*Extensions*

[none]
** 1a. The user missed out a parameter

** 1a1. H.M.U shows an error message. +

Use case ends.

[discrete]
== Use case: Delete person

*MSS*

1.  User requests to list persons
2.  H.M.U shows a list of persons
3.  User requests to delete a specific person in the list
4.  H.M.U deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. H.M.U shows an error message.
+
Use case resumes at step 2.

[discrete]
== Use case: Sort person

*MSS*

1. User requests to list persons
2. H.M.U shows a list of persons
3. User requests to sort contacts by name
4. H.M.U sorts contacts by name
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

[discrete]
== Use case: Help

*MSS*

1. User requests help
2. H.M.U opens a new help window
+
Use case ends.

[discrete]
== Use case: Edit person

*MSS*

1. User requests to edit person
2. User types in new particulars
3. AddressBook edits contact
+
Use case ends.

*Extensions*

[none]
* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[discrete]
== Use case: Create Default Account

*MSS*

1. User requests to create default account
2. User types in command
3. H.M.U creates default account for user
+
Use case ends.

*Extensions*

[none]
* 2a. A user account already exists.
+
[none]
** 2a1. H.M.U shows an error message.
+
Use case ends.

[discrete]
== Use case: Create Default Account

*MSS*

1. User requests to create default account
2. User types in command
3. H.M.U creates default account for user
+
Use case ends.

*Extensions*

[none]
* 2a. A user account already exists.
+
[none]
** 2a1. H.M.U shows an error message.
+
Use case ends.

[discrete]
== Use case: Change Passsword

*MSS*

1. User requests to change password
2. User types in username, old password and new password after command
3. H.M.U changes password for user
+
Use case ends.

*Extensions*

[none]
* 1a. User types in wrong command
+
[none]
** 1a1. H.M.U shows an error message
+
Use case resumes at step 1

* 1b. User does not have an account
+
[none]
** 1b1. H.M.U shows an error message
+
Use case ends

[none]
* 2b. User types in invalid username
+
[none]
** 2b1. H.M.U shows an invalid credentials message
+
Use case resumes at step 2

[none]
* 2c. User types in invalid password
+
[none]
** 2c1. H.M.U shows an invalid credentials message
+
Use case resumes at step 2

[discrete]
== Use case: Remove Login

*MSS*

1. User requests to remove login account
2. User types in username and password
3. H.M.U removes login account
+
Use case ends

*Extensions*

[none]

* 1a. User does not have account set up
** 1a1. H.M.U shows an error message
+
Use case ends

* 2a. User types in invalid username
+
[none]
** 2a1. H.M.U shows an invalid credentials message
+
Use case resumes at step 2

* 2b. User types in invalid password
+
[none]
** 2a2. H.M.U shows an invalid credentials message
+
Use case resumes at step 2

[appendix]

== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  The program should be able to start up within 5 seconds.
.  The program should be able to respond to any queries within 1 second.


[appendix]
== Glossary

Tag
--> A short phrase to describe your contact

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[private-contact-detail]]
Private contact detail

....
A contact detail that is not meant to be shared with others
....

[appendix]
== Product Survey

Handy Address Book

Author: Doctor Java

Pros:

* Functions Well
* Custom Categories
* Import/Export Contacts
* Label Printing
* Google Contacts Sync

Cons:

* Costly
