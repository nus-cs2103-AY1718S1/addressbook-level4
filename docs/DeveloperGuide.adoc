= ConTag - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-T15-B2/main/tree/master

{empty} +

image::contag_logo_ugdg.png[align="center"]

{empty} +

By: `T15-B2`      `Aw Wen Hao`      `Calvin Tantio`      `Cheng Jin Ting`      `Chung Tin Long`       Since: `Aug 2017`      Licence: `MIT`

== Introduction

Welcome to the ConTag's Developer Guide! Whether you are a beginner or an expert developer, if you are looking to improve and customise our ConTag application, this is the perfect place to get you started.

This comprehensive guide brings you all the necessary information you need to navigate around ConTag with ease, which includes:

* Step by step guide to set up your project
* Design and implementation of ConTag features

=== Overview of the ConTag Project

ConTag was initially developed to be an efficient and feature-packed desktop address book application for the most demanding business users and busiest frequent travellers.

=== How to Use the Developer Guide

The developer guide contains quite a number of information, so it can be quite intimidating. However, you do not have to read the developer guide in a linear order. Instead, you can use the linked content list at the top of this guide to navigate towards specific issues as needed.

This guide has been organised in a manner that mimics how you would go about developing your features. It starts with setting up your project to documenting your features implementation details, before ending off with additional information, such as User Stories and Glossary.

Finally, as you read the developer guide, you will see these two icons:

[NOTE]
This symbol indicates something for you to take note of.

[TIP]
This symbol indicates a tip to help you.

== Setting Up

=== Prerequisites

Before starting your project, make sure that you have all the following:

* *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

* *IntelliJ* IDE
+
[NOTE]
IntelliJ, by default, has Gradle and JavaFX plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

* Overall *understanding* and *knowledge* of `JAVA`
+
[NOTE]
This application is written in JAVA. +
All example codes in the guide uses JAVA language. +

=== Setting up the Project in Your Computer

. Fork this repository and clone the fork to your computer
. Open IntelliJ IDEA
[NOTE]
If you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first.
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it by clicking `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Windows) or `./gradlew processResources` (Mac/Linux)

If everything goes well, it should finish with the `BUILD SUCCESSFUL` message. This indicates the generation of all resources required by the application and tests.

=== Verifying the Setup

To make sure that the application runs as expected after the initial set up setting up, do the following:

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to Do Before Writing Code

==== Configuring the Coding Style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours. However, it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux) or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* Set `Class count to use import with '\*'` and `Names count to use static import with '*'` to `999` to prevent IntelliJ from contracting the import statements
* Configure `Import Layout` to follow the following order. You need to add `<blank line>` in between each `import`:

.. `import static all other imports`
.. `import java.\*`
.. `import javax.*`
.. `import org.\*`
.. `import com.*`
.. `import all other imports`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating Documentation to Match Your Fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repository. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based).

==== Getting Started with Coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

== Design

=== Architecture

This section will provide an overview of the high level architecture system used to design and implement the application , mainly
`Model` , `Logic` , `Storage` and `UI`.

The *_Architecture Diagram_* shown in _Figure 3.1.1_ below explains the high-level design of the App. Given below is a quick overview of each component.

image::Architecture.png[width="600"]
_Figure 3.1.1 : Architecture Diagram_

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level:

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components:

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see _Figure 3.1.2_ below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 3.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

_Figure 3.1.3a_ below shows the _Sequence Diagram_ for how the components interact in the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 3.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

_Figure 3.1.3b_ below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 3.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI Component

As seen from _Figure 3.2.1_ below, the UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

image::UiComponentClassDiagram.png[width="800"]
_Figure 3.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic Component

_Figure 3.3.1_ below shows the structure of the `Logic` component.

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

image::LogicClassDiagram.png[width="800"]
_Figure 3.3.1_ : Structure of the Logic Component

_Figure 3.3.2_ shows finer details concerning `XYZCommand` and `Command` in _Figure 3.3.1_.

image::NewCommandClassDiagram.PNG[width="800"]
_Figure 3.3.2_ : Structure of Commands in the Logic Component.

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

The following is a brief explanation on how the API is implemented:

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

_Figure 3.3.3_ below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 3.3.3 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model Component

The structure of the `Model` component can be seen in _Figure 3.4.1_ below.

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

image::ModelComponentClassDiagram.png[width="800"]
_Figure 3.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

=== Storage Component

The structure of the `Storage` component can be seen in _Figure 3.5.1_ below.

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

image::NewStorageComponentClassDiagram.PNG[width="800"]
_Figure 3.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

=== Common Classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.
Each sample code shows the correct sequence of calls and parameters in general implementation of the feature to allow you to perform modification of your own.

// tag::undoredo[]
=== Undo/Redo Mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. _Figure 4.1.1_ below shows the inheritance diagram for commands:

image::NewCommandClassDiagram.PNG[width="800"]
_Figure 4.1.1 : Inheritance diagram for commands_

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way in _Figure 4.1.2_:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----
_Figure 4.1.2 : Code section in ListCommand.java_

With the extra layer, the commands that are undoable are implemented this way in _Figure 4.1.3_:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----
_Figure 4.1.3 : Code section in UndoableCommand.java_

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

As depicted in _Figure 4.1.4_: The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]
_Figure 4.1.4 : UndoRedoStack diagram 1_

As depicted in _Figure 4.1.5_: As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]
_Figure 4.1.5 : UndoRedoStack diagram 2_

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

As depicted in _Figure 4.1.6_: We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]
_Figure 4.1.6 : UndoRedoStack diagram 3_

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The sequence diagram in _Figure 4.1.7_ below shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]
_Figure 4.1.7 : Undo sequence diagram_

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

As depicted in _Figure 4.1.8_: The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]
_Figure 4.1.8 : UndoRedoStack diagram 4_

As depicted in _Figure 4.1.9_: Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution.

image::UndoRedoNewCommand3StackDiagram.png[width="800"]
_Figure 4.1.9 : UndoRedoStack diagram 5_

The following activity diagram in _Figure 4.1.10_ below summarizes what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]
_Figure 4.1.10 : UndoRedoStack activity diagram_

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +
**Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`. +
**Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** Hard for new developers to understand the template pattern. +
**Alternative 2:** Just override `execute()` +
**Pros:** Does not involve the template pattern, easier for new developers to understand. +
**Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +
**Alternative 1 (current choice):** Saves the entire address book. +
**Pros:** Easy to implement. +
**Cons:** May have performance issues in terms of memory usage. +
**Alternative 2:** Individual command knows how to undo/redo by itself. +
**Pros:** Will use less memory (e.g. for `delete`, just save the person being deleted). +
**Cons:** We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +
**Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +
**Alternative 2:** Include all commands. +
**Pros:** Might be more intuitive for the user. +
**Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +
**Alternative 1 (current choice):** Use separate stack for undo and redo. +
**Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +
**Alternative 2:** Use `HistoryManager` for undo/redo. +
**Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]

// tag::deletemultiple[]
=== Deleting Multiple Persons [Since v1.1]

In _Figure 3.3.3_, the interactions in the `Logic` component are shown when a person is deleted. Since version 1.1, the `DeleteCommand` has been enhanced in its execution, to delete persons belonging to different indices keyed in by the user.

In the `DeleteCommandParser`, the user input string consisting of indices is extracted by splitting into tokens and storing them in an array, based on a whitespace delimiter. The parse method is also designed to throw an exception when the user inputs repeated indices. These can be observed from _Figure 4.2.1_ below.

[source,java]
----
public class DeleteCommandParser implements Parser<DeleteCommand> {

    public DeleteCommand parse(String args) throws ParseException {
        // Extract user input indices
        String[] indicesInString = trimmedArgs.split("\\s+");

        for (int i = 0; i < indicesInString.length; i++) {
            // ... parse each token ...

            // Check if there are repeated indices
            if (i >= secondParsedIndex) {
                for (Index indexInList: indices) {
                    if (indexInList.equals(index)) {
                        throw new ParseException(invalidCommandString);
                    }
                }
            }
            // ... add accepted indices to list for command execution...
        }
    }
}
----
_Figure 4.2.1 : Code section in DeleteCommandParser.java_

The `DeleteCommand` is initialised with an  `ArrayList` of indices, which is sorted in descending order, as shown below in _Figure 4.2.2_.

[source,java]
----
public class DeleteCommand extends UndoableCommand {

     public DeleteCommand(ArrayList<Index> targetIndices) {
            // sort in descending order
            Collections.sort(targetIndices);

            this.targetIndices = targetIndices;
        }
}

public class Index implements Comparable {
    // compareTo method overriden so that sorting list of indices can function as intended
    @Override
    public int compareTo(Object o) {
        Index compareIndex = (Index) o;

        return (compareIndex).getZeroBased() - this.zeroBasedIndex;
    }
}
----
_Figure 4.2.2 : Code section in DeleteCommand.java and Index.java_

The deletion of a `Person` will affect the value of the indices associated with the persons that come after it, during the iteration of the indices in the list. The indices have to be deleted from the highest value first to the lowest value, in order for the intended persons to be deleted.

Consider the scenario where a user wants to delete the persons at the first and second index from the list shown in _Figure 4.2.3a_. From the list shown, the user wants to delete persons 'Cheng Wei Hong' and `Liam William`.

image::DeleteScenario1.png[width="400"]
_Figure 4.2.3a : Original person list before deletion_

If the `Person` in the first index is deleted first the list will look like that in _Figure 4.2.3b_:

image::DeleteScenario2.png[width="400"]
_Figure 4.2.3b : Person List after deletion of first index_

After the second index is deleted, the list will be as shown in _Figure 4.2.3c_:

image::DeleteScenario3.png[width="400"]
_Figure 4.2.3c : Person List after deletion of first index_

As can be observed, 'Liam William' still exists in the list, which is not what the user intended. If the second index is deleted first followed by the first index, the list will appear as shown in _Figure 4.2.3d_:

image::DeleteScenario4.png[width="400"]
_Figure 4.2.3d : Person List after correct deletion of persons_

Hence, the list of index values is first sorted in descending order so that the persons associated with the highest index can be deleted first, as shown below in _Figure 4.2.4_.

[source,java]
----
public class DeleteCommand extends UndoableCommand {

     @Override
     public CommandResult executeUndoableCommand() throws CommandException {

         List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

         // iterate through already sorted list
         for (int i = 0; i < targetIndices.size(); i++) {
             // ... get target index ...

             ReadOnlyPerson personToDelete = lastShownList.get(targetIndex.getZeroBased());

             try {
                 model.deletePerson(personToDelete);
             } catch (PersonNotFoundException pnfe) {
                 assert false : "The target person cannot be missing";
             }
         }
         // ... return command result ...
     }
}

----
_Figure 4.2.4 : Code section in DeleteCommand.java_

==== Design Considerations

**Aspect:** User input restrictions +
**Alternative 1 (current choice):** Disallow repeated indices from user, even if indices can be found in the list. +
**Pros:** Prevent any deletion from occurring if user makes a mistake in keying in a repeated index. +
**Cons:** Less flexibility in keying indices for deletion. +
**Alternative 2:** Accept repeated indices, as long as they can be found in the list. +
**Pros:** Greater flexibility for user inputs. +
**Cons:** User will have to undo command if there is a mistake in keying in repeated indices.

---

**Aspect:** Implementation of `DeleteCommand` +
**Alternative 1 (current choice):** Delete all persons belonging to each index keyed in by the user. +
**Pros:** User able to delete persons belonging to random indices in the list all at once. +
**Cons:** Slow in deleting a large number of contacts at once as user has to key in index values 1 by 1. +
**Alternative 2:** Delete persons belonging to a range of indices. +
**Pros:** User is able to delete a lot of persons at once if they are listed consecutively. +
**Cons:** User will take a lot of time in deleting persons belonging to indices that are not next to each other.

---
// end::deletemultiple[]

// tag::help[]

=== Displaying the Usage of a Specific Command [Since v1.2]

This function is an enhancement of the existing help function, which opens the help window. The modification allows the `HelpCommand` to take in an optional `CommandIdentifier` argument. If the command identifier is specified, the result display panel will display the usage of the command specified. Otherwise, help window will be opened. This enhancement requires modifications in the `Logic` component of the application.

`CommandIdentifier` class is created to cater to the new type of argument that users can key in. The code section in _Figure 4.3.1_ below shows how it is implemented.

[source,java]
----
public class CommandIdentifier {

    // ... required public static final fields ...

    public CommandIdentifier(String commandIdentifier) throws IllegalValueException {
        requireNonNull(commandIdentifier);
        if (!isValidCommandIdentifier(commandIdentifier) && !commandIdentifier.equals("")) {
            throw new IllegalValueException(MESSAGE_COMMAND_WORD_CONSTRAINTS);
        }
        this.value = commandIdentifier;
    }

    public static boolean isValidCommandIdentifier(String test) {
       // ... returns true if the given string is a valid command identifier ...
    }
}
----
_Figure 4.3.1 : Code section in CommandIdentifier.java_

[NOTE]
A valid command identifier includes all existing command and their aliases.

For the Logic component, `HelpCommandParser` has been created to parse user input that follows the `help` command word. Refer to the code section in _Figure 4.3.2_ below to understand how it is implemented.

[source,java]
----
public class HelpCommandParser implements Parser<HelpCommand> {

    ...
    @Override
    public HelpCommand parse(String args) throws ParseException {
        if (args.trim().contains(" ")) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        try {
            CommandIdentifier commandIdentifier = ParserUtil.parseCommandIdentifier(args);
            return new HelpCommand(commandIdentifier);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }
}
----
_Figure 4.3.2 : Code section from HelpCommandParser.java_

To accommodate this enhancement, the following method, as shown in _Figure 4.3.3_ is added into `ParserUtil`. The method takes in user input string and return a `CommandIdentifier` object.

[source,java]
----
public static CommandIdentifier parseCommandIdentifier(String commandWord) throws IllegalValueException {
    requireNonNull(commandWord);
    return new CommandIdentifier(commandWord.trim());
}
----
_Figure 4.3.3 : Code section from ParserUtil.java_

Finally, the `CommandIdentifier` is passed into `HelpCommand` to do the command execution. _Figure 4.3.4_ shows how the help command execution is implemented.

[source,java]
----
public CommandResult execute() {
    // ... switch cases for all the command words and command aliases ...

    // ... default case: opens help window ...
}
----
_Figure 4.3.4 : Code section from CommandResult.java_

The following sequence diagram in _Figure 4.3.5_ shows an example that summarises how the `HelpCommand` is being called and executed.

image::HelpCommandLogicComponent.png[width="800"]

_Figure 4.3.5: Interactions Inside the Logic Component for the `help add` Command_

_Figure 4.3.6_ below shows the enhanced help command in action.

image::HelpEnhancementScreenShot.PNG[width="800"]

_Figure 4.3.6: Enhanced `HelpCommand` execution_

==== Design Considerations

**Aspect:** Enhancement of `HelpCommand` +
**Alternative 1 (current choice)**: `HelpCommand` allows the user to take in an optional `CommandIdentifier` argument. +
**Pros:** The user can easily find out about the format of a specific command he wants to execute. +
**Cons:** The users has to know the command identifier to utilise this feature. +
**Alternative 2:** `HelpCommand` can only allow the user to open help window.  +
**Pros:** It is simpler and more intuitive for a new user. +
**Cons:** The user has to go through the User Guide every time he needs to check on the usage of a specific command.
// end::help[]

//tag::locate[]
=== Locating a Contact's Address [Since v1.2]

This function is mainly facilitated by two events: `JumpToListRequestEvent` and `PersonPanelSelectionChangedEvent`.

The sequence diagram in _Figure 4.4.1_ below shows how the locate command is executed in the logic component:

image::LogicComponentSequenceDiagramLocate.png[width="800"]
_Figure 4.4.1 : Sequence Diagram for locating address in logic component_

Notice when the `LocateCommand` is being executed, after checking that the target index is valid, a new `JumpToListRequestEvent` is posted by the `EventsCenter` class to its `EventBus`, as shown in _Figure 4.4.2_:
[source,java]
----
public class LocateCommand extends Command {
    @Override
    public CommandResult execute() throws CommandException {

        //... check targetIndex ...

        EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex));

        //... return CommandResult ...
    }
}
----
_Figure 4.4.2: Code section in LocateCommand.java_

The UI part `PersonListPanel` is in charge of handling this event (i.e.`JumpToListRequestEvent`) , and does so by scrolling to the contact of the corresponding index and selecting it, as shown in _Figure 4.4.3_:
[source,java]
----
public class PersonListPanel extends UiPart<Region> {
    /**
     * Scrolls to the {@code PersonCard} at the {@code index} and selects it.
     */
    private void scrollTo(int index) {
        Platform.runLater(() -> {
            personListView.scrollTo(index);
            personListView.getSelectionModel().clearAndSelect(index);
        });
    }

    // Handling method for JumpToListRequestEvent
    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        scrollTo(event.targetIndex);
    }
}
----
_Figure 4.4.3: Code section in PersonListPanel.java_

The UI outcome of scrolling and selecting a `PersonCard` in the `PersonListPanel` is shown in Figure 4.3.4 below:

image::PersonListPanelSelect.png[width="400"]
_Figure 4.4.4 : UI outcome of scrolling and selecting a `PersonCard`_

When the constructor of `PersonListPanel` class is called, it will add a listener to the personListView which consists of a list view of each `PersonCard`. This listener ensures that a new `PersonPanelSelectionChangedEvent` will be raised when a new item in the list view is being selected. This can be shown below in _Figure 4.4.5_:
[source,java]
----
public class PersonListPanel extends UiPart<Region> {

    public PersonListPanel(ObservableList<ReadOnlyPerson> personList) {
        super(FXML);
        setConnections(personList); // calls addListenerForSelectionChangeEvent() method
        registerAsAnEventHandler(this);
    }

     /**
     * Creates a list of {@code PersonCard} from {@code personList}, sets them to the {@code personListView}
     * and adds listener to {@code personListView} for selection change.
     */
    private void setConnections(ObservableList<ReadOnlyPerson> personList) {
        //... set up personListView with personList ...
        addListenerForSelectionChangeEvent();
    }

    /**
     * Adds a listener to {@code personListView} so that
     * selected item raises {@code PersonPanelSelectionChangedEvent}.
     */
    private void addListenerForSelectionChangeEvent() {
        personListView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        logger.fine("Selection in person list panel changed to : '" + newValue + "'");
                        raise(new PersonPanelSelectionChangedEvent(newValue));
                    }
                });
    }
}
----
_Figure 4.4.5: Code section 2 in PersonListPanel.java_

The `BrowserPanel` contains a `WebView` which displays a web page of the google map location of the selected person's address. It is able to do so as it is an event subscriber for the `PersonPanelSelectionChangedEvent` as shown below in _Figure 4.4.6_:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {

    @Subscribe
    private void handleSelectionChangedEvent(PersonPanelSelectionChangedEvent event) throws IllegalValueException {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        loadPersonPage(event.getNewSelection().person);
    }
}
----
_Figure 4.4.6: Code section in BrowserPanel.java_

By being a subscriber to this event, the `WebView` in `BrowserPanel` will load the corresponding web page whenever a new
`PersonPanelSelectionChangedEvent` is posted to the `EventBus`. The sequence diagram in _Figure 4.4.7_ below shows how the raising of `PersonPanelSelectionChangedEvent` leads to the loading of the web page in `BrowserPanel`.

image::SequenceDiagramLoadPersonPage.png[width="800"]
_Figure 4.4.7 : Sequence diagram showing how the web page is loaded from `PersonPanelSelectionChangedEvent`_

_Figure 4.4.8_ below shows the full UI outcome of selecting a selecting a `PersonCard` in the `PersonListPanel`, as well as displaying the corresponding address location in `BrowserPanel`.

image::FullUIoutcomeLocateCommand.png[width="800"]
_Figure 4.4.8 : Full UI outcome of locate implementation_

==== Design Considerations

**Aspect:** Execution of `LocateCommand` +
**Alternative 1 (current choice):** Posts a new `JumpToListRequestEvent` to `EventBus`. +
**Pros:** `PersonCard` in `PersonListPanel` will be selected as shown in the UI, before location on Google Maps is displayed in `BrowserPanel`. Hence, the user will be able to see clearly the contact that is associated with the located address. +
**Cons:** Future developers will have to change execution of `LocateCommand` if they plan for to implement more useful events for card selection in `PersonListPanel`. +
**Alternative 2:** Post a new event directly for `BrowserPanel` to handle. +
**Pros:** Makes way for future implementations involving the selection in `PersonListPanel`. +
**Cons:** User will not able to view contact's location when a `PersonCard` is manually selected.

---
// end::locate[]

//tag::copy[]
=== Copy Email Address to Clipboard [Since v1.2]

The `copy` function uses the Clipboard in Toolkit API to automatically copy emails of selected indexes onto the system clipboard.
The index(es) selected must exist in the current result display window, as shown in _Figure 4.5.1_.

[source,java]
----
// copy string to clipboard
Toolkit toolkit = Toolkit.getDefaultToolkit();
Clipboard clipboard = toolkit.getSystemClipboard();
StringSelection messageOutputSelection = new StringSelection(messageOutput);
clipboard.setContents(messageOutputSelection, null);

----
_Figure 4.5.1: Code section in CopyCommand.java_

The selected emails are stored in a string ArrayList, then re-formatted to remove square brackets around the ArrayList and change all commas to semi-colons before sending the result to system clipboard output, as shown in _Figure 4.5.2_ below. This ensures that the final output string copied to clipboard has maximum compatibility with formatting conventions in email applications.

[source,java]
----
// outputList without square brackets
String messageOutput = outputList.toString().substring(1, outputList.toString().length() - 1);

// outputList use semi-colon separator
messageOutput = messageOutput.replace(",", ";");

----
_Figure 4.5.2: Code section 2 in CopyCommand.java_

_Figures 4.5.3a and 4.5.3b_ below show examples of copy command on display in the UI, showing the acceptable format for indexes, and the expected result. Note that the message will only be displayed if the message is already copied to the system clipboard.:


image::CopyCommand_single_index.PNG[width="400"]
_Figure 4.5.3a : Copy from a single contact_

image::CopyCommand_multiple_index.PNG[width="400"]
_Figure 4.5.3b : Copy from multiple contacts_

_Figure 4.5.4_ below shows an applied use of this command in an e-mail application--addresses automatically detected upon clipboard paste

image::CopyCommand_browser_result.PNG[width="800"]
_Figures 4.5.4: Applied use of command in email application_

==== Design Considerations for `CopyCommand`

There was no way to copy emails from the listed contacts in the previous version, so a user would have to refer to the address book application while typing it into their email application or browser manually. As email addresses are almost always meant to be utilized in an electronic device, an automatic ‘copy’ command of all requested email addresses is the most efficient and user-friendly way of text selection for this type of information.

Multiple emails are copied rather than other fields as it is the most used mode of communication in a personal computer (PC),
which is where this application resides. We expect this feature to be used for people who do not use their PC's native Mail app feature,
in which case the Email command cannot be used. Those who want to share their contacts' email details with others can also
save time with this command.

*Alternatives considered*

Phone numbers are seldom used as PCs do not typically have the ability to perform voice calls, and even web calls such as
Skype calls are usually able to take in both email and phone number inputs. Meanwhile, the physical address does not have
an urgent need to be copied as the Locate command in our app already copies the address and displays it on Google Maps.
As such, until user feedback proves otherwise, copying email addresses is the main priority for this feature.

**Aspect:** Which field(s) to copy +
**Alternative 1 (current choice):** Email address. +
**Pros:** Emails more widely copied than any other field. +
**Cons:** Users who want to copy other fields cannot do so. +
**Alternative 2:** All fields can be copied with their respective identifiers (e.g. address/, phone/) +
**Pros:** Users gain flexibility to copy any field required. +
**Cons:** Creates more confusion and delay for users because they have to also type the identifier.

Alternative 3: it may also be possible to permanently display all fields in each contact listing as selectable text. However, this means that the user is required to select each line of text via user interface rather than command line, which contradicts a core requirement of the project.

---

**Aspect:** How to implement copy for multiple contacts' information +
**Alternative 1 (current choice):** Select by index (1 2 3 etc.) +
**Pros:** Simpler and more efficient for small numbers (e.g. under 4 contacts on average) +
**Cons:** Prohibitively difficult for selecting large numbers of contacts. +
**Alternative 2:** Select by index range (1 - 3 etc.) +
**Pros:** Easier to selec large numbers of contacts +
**Cons:** Confusing for users who want to skip between indexes often.

In terms of mode of input, current multiple email copy works with one or more indices as the user can already filter for a small list of people
that may be of interest, cutting the amount of scrolling significantly. In addition, as we assume that most users
using the application would not have to send email to a massive number of recipients at a time, which may cause our implementation
to become prohibitively inefficient.

However, eventually allowing the command to accept a range of indices (copy 1 - 4 rather than 1 2 3 4), and even a "copy all"
command that takes in all currently displayed contacts, are potential planned features for v 2.0. We may need to conduct investigation
of user preferences and usage patterns to decide which input methods to include, as allowing too many modes of input can be
confusing to novice users and inefficient for the app to process (thereby increasing wait time and resource usage).

//end::copy[]

---

//tag::calendar[]
=== Opening Calendar [Since v1.3]

`CalendarCommand` which reside in `Logic` will  open up a new browser webpage in the `BrowserPanel` that shows calendar for the entire year. The webpage will display the calendar from January to December, inclusive of public holidays.User are also able to navigate to other website that show useful information such as weather, time zone and more.

The sequence diagram of `CalendarCommand` in _Figure 4.6.1_ below indicates the sequence diagram of the calendar function.

image::SequenceDiagramCalendar.PNG[width="800"]
_Figure 4.6.1 : Calender sequence diagram_

Upon taking in `CalendarCommand`  in the command line, a new `ShowCalendarRequestEvent` is posted by the `EventsCenter` class to its `EventBus`, as shown in _Figure 4.6.2_.  In addition , user are able  bypass `CalendarCommand` by pressing on `F2` key to post `ShowCalendarRequestEvent` thus allow user to launch calendar webpage via command line or via accelerators.

[source,java]
----
public class CalendarCommand extends Command {
    @Override
    public CommandResult execute() throws CommandException {

        EventsCenter.getInstance().post(new ShowCalendarRequestEvent());
      //  return new CommandResult
    }
}

----
_Figure 4.6.2: Code section in CalendarCommand.java_

The component diagram in _Figure 4.6.3_ below indicates the interactions within the Logic component for the execution of calendar command.

image::CalendarCommandComponentDiagram.PNG[width="800"]
_Figure 4.6.3 : Calender sequence diagram_



The  `BrowserPanel`  which reside in `UI` will handle the event of `ShowCalendarRequestEvent`
as shown in _Figure 4.6.4_:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {
@Subscribe
    private void handleCalendarRequestEvent(ShowCalendarRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        loadCalendar();
   }
}
----
_Figure 4.6.4: Code section in BrowserPanel.java_

The method `loadCalendar` in `BrowserPanel` will load the page with the calendar url passed in as parameters to open up calendar website. The outcome of successful launching of calendar webpage is shown in _Figure 4.6.5_:

image::CalendarCommand.png[width="800"]

_Figure 4.6.5: Output of `CalendarCommand.java` execution_

==== Design Considerations

**Aspect:** Implementation of `CalendarCommand` +
**Alternative 1 (current choice)**: Opening  `Calendar` web page in `BrowserPanel`. +
**Pros:** To brings about greater convenience for the user as user does not need to navigate between multple webpages to find the calendar. User are able to find out about the public holidays which are not avaliable on desktop calendar. +
**Cons:** User might bypass the `CalendarCommand` and rely on desktop calendar. +
**Alternative 2:** Opening up of Google calendar. +
**Pros:** User are able to store the events in the google calendar. +
**Cons:** Unable to view public holidays.User also have to go through the hassle of logging in just to view the calendar. +

---
//end::calendar[]

// tag::multipleemails[]
=== Support for Adding or Editing Contact with Multiple Emails [Since v1.3]

Since version 1.3, more than one email can be saved to a `Person` and all emails can be displayed in the `PersonCard`. The `AddCommand` and `EditCommand` provides support to this enhancement.
The method to parse all email inputs in `ParserUtil` returns a set of `Email` from a collection of user input emails, as seen in _Figure 4.7.1_ below.

[source,java]
----
public class ParserUtil {
    public static Set<Email> parseEmails(Collection<String> emails) throws IllegalValueException {
        requireNonNull(emails);
        final Set<Email> emailSet = new HashSet<>();
        for (String emailName : emails) {
            emailSet.add(new Email(emailName));
        }
        return emailSet;
    }
}

----
_Figure 4.7.1: Code section in ParserUtil.java_

A set of `Email` is returned after parsing, which is stored as a `UniqueEmailList` when the `Person` is constructed. However, the `Person` class is constructed at different times for the add and edit features.
For adding a contact, the `Person` is constructed in `AddCommandParser` as shown in _Figure 4.7.2_ below, after the email inputs have been parsed.

[source,java]
----
public class AddCommandParser implements Parser<AddCommand> {
    public AddCommand parse(String args) throws ParseException {

        // ... Parse other fields ...
        Set<Email> emails = ParserUtil.parseEmails(argMultimap.getAllValues(PREFIX_EMAIL));
        // ... Parse other fields ...

        ReadOnlyPerson person = new Person(name, phone, country, emails, address, schedule, tagList);
    }
}

----
_Figure 4.7.2: Code section in AddCommandParser.java_

For editing a contact, the `Person` is constructed during the execution of the command, whereby the `Person` will be updated with the new set of `Email`, as shown below in _Figure 4.7.3_.

[source,java]
----
public class EditCommand extends UndoableCommand {
    public CommandResult executeUndoableCommand() throws CommandException {

        // ... Get person to edit ...

        Person editedPerson = createEditedPerson(personToEdit, editPersonDescriptor);

        // ... Update model ...
    }

    private static Person createEditedPerson(ReadOnlyPerson personToEdit,
                                                 EditPersonDescriptor editPersonDescriptor) {

        // ... get other updated fields ...
        Set<Email> updatedEmail = editPersonDescriptor.getEmails().orElse(personToEdit.getEmails());
        // ... get other updated fields ...

        return new Person(updatedName, updatedPhone, updatedCountry, updatedEmail, updatedAddress,
                        updatedSchedule, updatedTags);
    }
}

----
_Figure 4.7.3: Code section in EditCommand.java_

The `UniqueEmailList` in `Person` stores the set of emails as an observable list, as can be seen in _Figure 4.7.4_ below when the `UniqueEmailList` is initialised with the set of emails.

[source,java]
----
public class UniqueEmailList {
    private final ObservableList<Email> internalList = FXCollections.observableArrayList();

    public UniqueEmailList(Set<Email> emails) {
        requireAllNonNull(emails);
        internalList.addAll(emails);
    }
}

----
_Figure 4.7.4: Code section in UniqueEmailList.java_

==== Design Considerations

**Aspect:** Storing of emails in `Person` +
**Alternative 1 (current choice)**: Emails stored as `ObjectProperty` of `UniqueEmailList`. +
**Pros:** We are able to add listeners to track changes in the object `UniqueEmailList`. +
**Cons:** Need to call more methods to get the set of emails. +
**Alternative 2:** Emails stored as a set. +
**Pros:** Able to get the set of emails and use it from a simple getter method. +
**Cons:** We are unable to track changes in the email list if we want the UI to change accordingly.
// end::multipleemails[]

//tag::country_code[]
=== Country of Contact [Since v1.3]

When a contact is added or edited, its phone number is checked for existence of a country code prefix, e.g. "+1 ".
The country code is extracted from the phone number in several steps:

1) The incoming phone number is first checked for either being with, or without a country code prefix.
If it is identified to have one, it will then be checked against a list of valid country codes.

[source,java]
----
    private static final String PHONE_VALIDATION_REGEX = "\\d{4,16}";
    // with country code prefix
    // current regex DOES NOT INCLUDE codes from 1000 onwards!
    private static final String PHONE_VALIDATION_REGEX_ALT =
        "\\+(9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|"
                + "6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)\\s\\d{4,16}$";

----
_Figure 4.8.1: From Phone.java; checks for either any valid string of numbers (top), or a specific list of
existing countries' codes if the plus sign is detected._

2) The plus sign `+` is detected, triggering the extraction.

3) The digits are taken until a white space is detected, denoting the end of the country code.

[source,java]
----
    public static String trimCode(String trimmedPhone) {
        // only attempt to extract country code if regex is ALT
        if (trimmedPhone.matches(PHONE_VALIDATION_REGEX_ALT)) {
            // take pattern: end with whitespace (expected for ALT regex)
            String[] split = trimmedPhone.split("\\s+");
            return (split[0].trim()).substring(1);
        } else {
            return DEFAULT_COUNTRY_CODE.trim();
        }

----
_Figure 4.8.2: From Phone.java; extracts the digits starting after plus sign and before white space._

Finally, the country code obtained is then sent to the Country class, where it is compared against a `Hashmap` of
country code and name Strings, as shown in Figure 4.8.3:

[source,java]
----
    /**
     * Creates map of country codes and names.
     */
    public static Map <String, String> createMap() {
        Map <String, String> countries = new HashMap<>();
        // NOTE: all country codes with prefix "1-" and "44-" are not yet allowed by regex.
        countries.put(DEFAULT_COUNTRY_CODE, DEFAULT_COUNTRY);
        countries.put("65", "Singapore");
        countries.put("93", "Afghanistan");
        countries.put("355", "Albania");
        countries.put("213", "Algeria");
        countries.put("1-684", "American Samoa");
        ...
        (100+ more lines of countries populated)
        ...
        codeList = new ArrayList<String>(countries.keySet());
                Collections.sort(codeList);
                return countries;
        }
----
_Figure 4.8.3: From Country.java_

Note that the above default country code and name are defined as such:

[source.java]
----
    public static final String DEFAULT_COUNTRY_CODE = "";
    public static final String DEFAULT_COUNTRY = "Country Unavailable";
----
_Figure 4.8.4: From Country.java_

Meanwhile, codeList is instantiated at the end of the HashMap population to facilitate easier output of the full list
in alphabetical order, should the user want to find out whether the code they are using is inside our database.
This is expected to be a beta-only feature to facilitate bug reports and troubleshooting, and may not be necessary in
the official release:

[source.java]
----
    public static String getCodeList() {
        int count = 0;
        String output = "Valid codes:";
        for (String code:codeList) {
            if (count < 29) {
                output += code + ", ";
            } else {
                output += code + ", \n";
            }
            count += 1; // record iterations until next newline
            count = count % 30; // repeat to 30
        }
        return output;
    }
----
_Figure 4.8.5: From Country.java; getCodeList() includes output formatting to accommodate the size limitations of the
result display box, when called by HelpCommand._

As the extra feature to display our supported code list is expected to be temporary, it is called by `help codes` with
HelpCommand, rather than as a stand-alone help class.

Observe in Figure 4.8.6 below, that the contact shows `Country Unavailable` when a generic phone number
is used without a country code prefix. When its phone number field is edited in Figure 4.8.7, the country
name field automatically changes to `Singapore` upon returning the command.

image::country_code demo 1.PNG[width="00"]
_Figure 4.8.6 : Country code shows unavailable status when no code is entered._

image::country_code demo 2.PNG[width="700"]
_Figure 4.8.7 : Country name updated once a matching country code is added to phone number._

Note that as shown in Figure 4.8.8, country codes that do not belong to any valid country or state will be
rejected. The current list of acceptable codes can be listed with the command `help codes`.

image::country_code demo 3.PNG[width="800"]
_Figure 4.8.8 : Copy from multiple contacts_

==== Design Considerations

Most importantly, this feature allows the user to skip the input of a new contact's country, and makes the country section
of the Address input optional as well. This reduces the number of steps during contact creation and modification.

This implementation involves detecting the start and end of the country code prefix in a phone number with "+" and " "
respectively because this is a widely used international convention, and the plus sign and first white space are unique.
This allows for completely reliable detection of the start and end of every country code. Codes are validated against a current
local database of all valid country codes (at time of application release) and invalid codes are rejected, so that users are
notified of user input errors immediately.

The default "Country not available" status for numbers with no country code are designed to give completeness and symmetry to
the contact list, so that users are not left wondering if the "missing" line in some contacts are from deliberate design.
We expect to update shortly and be able to detect and infer the country name from the Address.

A future update will include support for multiple phone numbers as a standard, with multiple countries displayed if phone
numbers differ in country codes, as well.

*Alternatives Considered*

This idea started with creating a field for standalone input of Country name. However, as this would be a tedious extra step that
many users may skip, we decided to infer this field from existing information instead. Depending on user feedback, we may want to re-open
the idea of allowing custom user-defined input, concurrent to a default country inference when a contact is first made.

**Aspect:** How to input Country name +
**Alternative 1 (current choice):** Automatic detection from phone number. +
**Pros:** Fewer steps by user, ensures all contacts have country. +
**Cons:** User cannot change a custom country for contact.  +
**Alternative 2:** Automatic detection from address +
**Pros:** Fewer steps by user, does not rely on phone prefixes. +
**Cons:** User may not input country in some addresses. +
**Alternative 3:** Manual entry of contact's country. +
**Pros:** Guarantees satisfactory country field as defined by user. +
**Cons:** More steps, users may not want to expend the extra time while populating address book over time.

---
//end::country_code[]

//tag::scheduleSingle[]
=== Scheduling an Activity with a Single Person [Since v1.3]

The `ScheduleCommand` allows the user to schedule and activity with one person in the contact list per execution. It is one of the commands that extend `UndoableCommand`. This allows users to `undo` their scheduling. `UndoableCommand`, in turn, inherits from `Command` as shown in _Figure 4.9.1_ below.

image::ScheduleCommandLogicCommandClassDiagram.png[width="800"]

_Figure 4.9.1 : Inheritance diagram for commands_

The diagram in _Figure 4.9.2_ below shows the sequence of the schedule operation.

image::ScheduleCommandLogic.png[width="800"]

_Figure 4.9.2 : Interactions inside the `Logic` component for the `schedule 1 d/15-12-2017 act/Meeting` command execution_

The `ScheduleCommand` takes in `Index`, which is already available in the v1.0 code, as well as `ScheduleDate` and `Activity`. The Model component of the application has been extended to include the two new classes.

`DateUtil` has also been created to make sure that users enter a valid data which follows DD-MM-YYYY format. The code snippet in _Figure 4.9.3_ below shows how `DateUtil` checks the validity of an input date.

[source, java]
----

private static final String DATE_VALIDATION_REGEX = "\\d{2}-\\d{2}-\\d{4}";

public static boolean isValid(String date) {
    return (hasValidFormat(date) && isActualDate(date));
}

public static boolean hasValidFormat(String date) {
    requireNonNull(date);
    date = date.trim();
    return date.matches(DATE_VALIDATION_REGEX);
}

private static boolean isActualDate (String date) {
    // ... check if the date exists by considering day, month and year ...
}
----

_Figure 4.9.3 : Code section from DateUtil.java_

The activity scheduled will be displayed together with the other components of a contact as shown in _Figure 4.9.4_ below.

image::ScheduleCommandSingleScreenShot.png[width="400"]

_Figure 4.9.4 : UI display of a successful `ScheduleCommand` execution_

==== Design Considerations

**Aspect:** Creation of master schedule list +
**Alternative 1 (current choice)**: A master schedule list is created to store all the unique activities scheduled. +
**Pros:** It is possible to utilise the master schedule list to display all the unique schedules that the user has scheduled. +
**Cons:** The master schedule list has to be synchronised with all the schedules attached to all persons in the contact list every time a new schedule is added. +
**Alternative 2:** A master schedule list is not created.  +
**Pros:** It is easier to implement.  +
**Cons:** The user can only search for an activity scheduled by searching for the person he has scheduled the activity with.

[NOTE]
This choice facilitates the creation of the link:#viewing-of-user-s-agenda-since-v1-4[agenda panel].

---

**Aspect:** The choice of valid date format +
**Alternative 1 (current choice)**: DD-MM-YYYY is the only valid date format. +
**Pros:** It is possible to determine which date comes first and which comes later. +
**Cons:** The user has lesser flexibility in inputting dates. +
**Alternative 2:** Both DD-MM and DD-MM-YYYY are acceptable date formats.  +
**Pros:** This gives the user more flexibility when inputting dates.  +
**Cons:** This creates ambiguity when arranging the schedules based on dates.

[NOTE]
Since v1.4, schedules in both the agenda panel and the person cards are arranged based on dates.

//end::scheduleSingle[]

//tag::scheduleMultiple[]
=== Scheduling an Activity with Multiple Persons [Since v1.4]

This enhancement builds upon the schedule feature developed in v1.3, which allows the user to schedule an activity with only one person. With this enhancement, the user can now input multiple indices to schedule an activity with multiple persons at the same time.

The schedule attached to a contact is stored inside a `List`, and is sorted based on the `ScheduleDate` every time a new `Schedule` is added.

The implementation of `Comparable` interface for `Schedule` allows the activities scheduled with a person to be displayed from the earliest date to the latest date. The code section in _Figure 4.10.1_ below shows how the `compareTo()` function is being defined in the `Schedule` class.

[source, java]
----
public class Schedule implements Comparable<Schedule> {
    ...
    @Override
    public int compareTo(Schedule scheduleToCompare) {
        String schedule1DateInString = this.getScheduleDate().value;
        String schedule2DateInString = scheduleToCompare.getScheduleDate().value;

        int schedule1Year = DateUtil.getYear(schedule1DateInString);
        int schedule2Year = DateUtil.getYear(schedule2DateInString);
        if (schedule1Year != schedule2Year) {
            return schedule1Year - schedule2Year;
        }

        int schedule1Month = DateUtil.getMonth(schedule1DateInString);
        int schedule2Month = DateUtil.getMonth(schedule2DateInString);
        if (schedule1Month != schedule2Month) {
            return schedule1Month - schedule2Month;
        }

        int schedule1Day = DateUtil.getDay(schedule1DateInString);
        int schedule2Day = DateUtil.getDay(schedule2DateInString);
        return schedule1Day - schedule2Day;
    }
}
----

_Figure 4.10.1 : Code section from Schedule.java_

The outcome of schedule multiple command execution is shown in _Figure 4.10.2_ below.

image::ScheduleCommandMultipleScreenShot.png[width="400"]

_Figure 4.10.2 : UI display of a successful enhanced `ScheduleCommand` execution_

==== Design Considerations

**Aspect:** Data structure to support multiple indices input +
**Alternative 1 (current choice)**: `Set` is used to store indices input. +
**Pros:** The application becomes smart enough to eliminate duplicate indices input and speed up the `ScheduleCommand` execution. +
**Cons:** There is a need to override the `hashCode()` and `equals()` methods in the `Index` for the `Set` implementation to work correctly. +
**Alternative 2:** `ArrayList` is used to store indices input. +
**Pros:** `List` implementation allows the indices input to be stored in order; and hence, easier to manipulate if required.  +
**Cons:** The user receives an error message if he inputs non-unique indices.

---

**Aspect:** Data structure to support scheduling multiple activities with a contact +
**Alternative 1 (current choice)**: `ArrayList` is used to store multiple schedules. +
**Pros:** This makes it possible to arrange the schedules based on dates. +
**Cons:** There is a need to check for duplicate schedules so that all the schedules attached to a person are unique. +
**Alternative 2:** `Set` is used to store multiple schedules.  +
**Pros:** There is no need to specially check for duplicate schedules. +
**Cons:** `Set` does not provide any ordering guarantees for the schedules.
//end::scheduleMultiple[]

//tag::find[]
=== FindCommand by Any Search Field [Since v1.2 and v1.4]


`FindCommand` which reside in `Logic` will support the search of contact by any keywords. `Logic` uses the `AddressBookParser` class to parse user command. `parseCommand` in `AddressBookParser` will detect the command word `find` and the keywords keyed in by user and call `parse` method in `FindCommandParser`.`parse` method in `FindCommandParser` will check for the prefix based existing parameters `Name`, `Email`, `Address`, `Phone`,`Tags` , `Activity` and `Country`. Such parameters inherit from `Person` which resides inside `Model`. _Figures 4.11.1_ indicates the the parsing of user command in  `FindCommandParser`.

[source,java]
----
public class FindCommandParser implements Parser<FindCommand> {
    public FindCommand parse(String args) throws ParseException {
        final String prefix = matcher.group("prefix");
        final String arguments = matcher.group("arguments");

           //switch case to identify the the prefix for allocation of searched keywords into its predicate

}

----
_Figure 4.11.1: Code section in FindCommandParser.java_

[NOTE]
A valid find command can only search for keywords based on specific prefix  [n/NAME] or [p/PHONE] or [e/EMAIL] or [a/ADDRESS] or [t/TAG] or [c/COUNTRY] or [act/ACTIVITY].

Any other prefix as input will be considered as invalid input.In absence of valid prefix ,an exception will be thrown in  `FindCommandParser`, as shown in _Figure 4.11.2_.
[source,java]
----
         default:
                    throw new ParseException(MESSAGE_UNKNOWN_FINDCOMMAND);
----
_Figure 4.11.2: Code section 2 in FindCommandParser.java_

A successful match of the prefix in `FindCommandParser` will create a `FindCommand` object with `containsKeyWordPredicate` that resides in `Model` to be passed as parameter.Command execution in `LogicManager` will then call `updateFilteredPersonList` method in `ModelManager`.Addressbook will then search for contact based on the predicate paramater passed in `PredicateUtil` as shown in _Figure 4.11.3_.
.
[source,java]
----
public class PredicateUtil {
//Search for contact based on fields from containsKeyWord Predicate
}

----
_Figure 4.11.3: Code section  in PredicateUtil.java_

The component diagram in _Figure 4.11.4_ below shows the interactions within the Logic component for the execution of find command.

image::LogicComponentSequenceDiagramFind.PNG[width="800"]
_Figure 4.11.4 : Find component diagram_

The sequence diagram in _Figure 4.11.5_ below shows how the find function works:

image::SequenceDiagramFind.PNG[width="800"]
_Figure 4.11.5 : Find sequence diagram_

Upon any successful match, the particulars of the contact will be displayed in `CommandBox`. _Figures 4.11.6a to 4.11.6g_ below indicate the various outcomes of search function by  using `FindCommand`.

image::FindCommand_Name.PNG[width="400"]
_Figure 4.11.6a : Find by name [n/NAME]_

image::FindCommand_Phone.PNG[width="400"]
_Figure 4.11.6b : Find by phone [p/PHONE]_

image::FindCommand_Email.PNG[width="400"]
_Figure 4.11.6c : Find by email [e/EMAIL]_

image::FindCommand_Address.PNG[width="400"]
_Figure 4.11.6d : Find by address [a/ADDRESS]_

image::FindCommand_Activity.PNG[width="400"]
_Figure 4.11.6e : Find by activity [act/ACTIVITY]_

image::FindCommand_Tag.PNG[width="400"]
_Figure 4.11.6f : Find by tag [t/TAG]_

image::FindCommand_Country.PNG[width="400"]
_Figure 4.11.6g : Find by country [c/COUNTRY]_

==== Design Considerations

**Aspect:** Enhancement of `FindCommand` +
**Alternative 1 (current choice)**: Searching for contact based on the `prefix` of search field given. +
**Pros:** To brings about greater convenience for the user during the searching process. User no longer not restricted to find contact by name soley. +
**Cons:** User have to be know the various `prefixes` in order to be able to search for the contract via the attribute of the contact. +
**Alternative 2:** Searching for contact without having the need to input prefix +
**Pros:** Easier for users to find a contact without the hassle to have full knowledge of the various `prefixes`. Might be more intuitive for user. +
**Cons:** Have to look through all the attribute of contact thus slowing down the execution of FindCommand. +

---
//end::find[]

// tag::agenda[]
=== Viewing of User's Agenda [Since v1.4]

All scheduled activities by the user are displayed as a list view in the `AgendaPanel`. The `AgendaPanel` is first initialised in the `MainWindow`, with the observable schedule list of the `AddressBook` being passed in as a parameter to its constructor. This can be observed in _Figure 4.12.1_ below.

[source,java]
----
public class MainWindow extends UiPart<Region> {
    void fillInnerParts() {
        // ... Initialise other UI parts ...

        agendaPanel = new AgendaPanel(model.getAddressBook().getScheduleList());

        // ... Initialise other UI parts ...
    }
}

----
_Figure 4.12.1: Code section in MainWindow.java_

Each schedule in the schedule list is represented as a `ScheduleCard`. Each `ScheduleCard` can be viewed in each cell of the list view. The `AgendaPanel` connects each schedule to a `ScheduleCard` as seen in _Figure 4.12.2_ below.

[source,java]
----
public class AgendaPanel extends UiPart<Region> {
    private void setConnections(ObservableList<Schedule> scheduleList) {
        ObservableList<ScheduleCard> mappedList = EasyBind.map(
                scheduleList, (schedule) -> new ScheduleCard(schedule, scheduleList.indexOf(schedule) + 1));

        // ... Set items to list view ...
    }
}
----
_Figure 4.12.2: Code section in AgendaPanel.java_

New additions to the `AddressBook` schedule list will be reflected in the schedule cards and changes in any schedule will be reflected in the cards themselves. This is implemented as shown in _Figure 4.12.3_ below:

[source,java]
----
public class ScheduleCard extends UiPart<Region> {
     private void bindListeners(Schedule schedule) {
        activity.textProperty().bind(Bindings.convert(schedule.getActivityProperty()));
        date.textProperty().bind(Bindings.convert(schedule.getScheduleDateProperty()));
        schedule.getPersonInvolvedNamesProperty().addListener((observable, oldValue, newValue) -> {
            personNames.getChildren().clear();
            initPersonNames(schedule);
        });
    }
}
----
_Figure 4.12.3: Code section in ScheduleCard.java_

The UI outcome for the `AgendaPanel` consisting of a few schedules can be seen below in _Figure 4.8.4_.

image::AgendaPanelUI.png[width="400"]
_Figure 4.12.4: UI display for user's agenda_

==== Design Considerations for Viewing of User's Agenda

**Aspect:** Location of agenda +
**Alternative 1 (current choice)**: Agenda can be viewed in the `MainWindow`. +
**Pros:** User is able to view the agenda immediately upon starting the application. +
**Cons:** The `AgendaPanel` compromises the space allocated to the `BrowserPanel`. +
**Alternative 2:** Agenda is located in a separated window, which can be opened using a command input +
**Pros:** More space will be allocated to `BrowserPanel`, hence the user can enjoy a larger view of a contact's address location. User also has the freedom to minimise or expand agenda window. +
**Cons:** User needs to take the extra step to view the agenda, he or she may forget about the scheduled activities if agenda is not opened. +

---
// end::agenda[]

//tag::welcomeScreen[]
=== Welcome Screen Display [Since v1.5]

If enabled, the welcome screen will be launched before the main window is displayed. The information regarding the enabling or disabling of welcome screen is stored inside `preferences.json` file, which is accessed and modified by `UserPrefs` class.

`UserPrefs` contains boolean variable `isWelcomeScreenEnabled`, which is initially set to false. This means that the welcome screen is disabled by default.

To facilitate the enabling and disabling of welcome screen, `WelcomeCommand`, which takes in `EnablingKeyword` argument, is created.

[NOTE]
`EnablingKeyword` guarantees two possible values: `enable` and `disable`.

Depending on the value of `EnablingKeyword`, `WelcomeCommand` will call one of the following two methods in `UserPrefs`, as shown by the code section in _Figure 4.13.1_, to change the `isWelcomeScreenEnabled` value in `preferences.json`.

[source, java]
----
public class UserPrefs {
    ...
    private boolean isWelcomeScreenEnabled = false;
    ...
    public void enableWelcomeScreen() {
        isWelcomeScreenEnabled = true;
    }

    public void disableWelcomeScreen() {
        isWelcomeScreenEnabled = false;
    }
    ...
}
----

_Figure 4.13.1 : Code section from UserPrefs.java_

Every time the application is run, `UiManager` will call `getWelcomeScreenEnabledInfo()` in `UserPrefs` to check whether the welcome screen is enabled. The code section in _Figure 4.13.2_ below shows how this is implemented.

[source, java]
----
public void start(Stage primaryStage) {
    ...
    try {
        welcomeScreen = new WelcomeScreen(primaryStage, config, prefs, logic, model);
        if (prefs.getWelcomeScreenEnabledInfo()) {
            welcomeScreen.show(); //This should be called before creating other UI parts
            welcomeScreen.fillInnerParts();
        } else {
            welcomeScreen.loadMainWindow();
        }
        ...
    } catch (Throwable e) {
        ...
    }
    ...
}
----

_Figure 4.13.2 : Code section from UiManager.java_

_Figure 4.13.3_ below shows the UI display of the as implemented in the `WelcomeScreen`. The welcome screen displays the ConTag logo and 1 out of the default 15 productivity quotes at random.

image::WelcomeScreen.png[width="400"]

_Figure 4.13.3 : The welcome screen_

When the "Continue" button is pressed, `WelcomeScreen` will pass the `MainWindow` scene into the `primaryStage`, replacing `WelcomeScreen` with `MainWindow`.

==== Design Considerations

**Aspect:** Nature of the welcome screen +
**Alternative 1 (current choice)**: The users' action is required to close the welcome screen. +
**Pros:** This enables the developer to customise the text on the welcome screen as required, such as tips or important notice. This is because the user will have enough time to read the text on the welcome screen. +
**Cons:** A button is required to handle the passing of scenes into the `primaryStage`. +
**Alternative 2:** Welcome screen closes by itself after a fixed period of time.  +
**Pros:** It does not require additional button; and hence, is more straightforward to implement.  +
**Cons:** Welcome screen can only display logo and minimum text as it is not guaranteed that the user can read the text within the period the welcome screen is displayed.

---

**Aspect:** Disabling of the welcome screen +
**Alternative 1 (current choice)**: The user has the choice to enable or disable the welcome screen. +
**Pros:** Some users who do not want the welcome screen to be displayed can save time by skipping the welcome screen. +
**Cons:** A new command must be created to cater to this purpose. +
**Alternative 2:** Welcome screen is always displayed when the application is run.  +
**Pros:** This does not require additional command to be implemented.  +
**Cons:** All users are forced to wait for the the welcome screen to launch before the main window. Some users may not be contented.
//end::welcomeScreen[]

// tag::reminder[]
=== Pop-up Reminder Window [Since v1.5]

The `AddressBook` consists of 2 schedule lists: one contains all the scheduled activities by the user, while the other contains the scheduled activities that the user need to be reminded of. +
If there exists any activities that the user need to be reminded of, a `ReminderWindow` will open after the `MainWindow`, as shown in _Figure 4.14.1_ below.

[source,java]
----
public class UiManager extends ComponentManager implements Ui {
     @Override
     public void start(Stage primaryStage) {

        //... Initialise MainWindow ...

        // show reminder pop-up if there exists upcoming activities the next day
        ReadOnlyAddressBook addressBook = model.getAddressBook();
        ObservableList<Schedule> schedulesToRemindList = addressBook.getScheduleToRemindList();

        if (!schedulesToRemindList.isEmpty()) {
            ReminderWindow reminderWindow = new ReminderWindow(schedulesToRemindList);
            reminderWindow.show();
        }
     }
}
----
_Figure 4.14.1: Code section in UiManager.java_

The `Reminder Window` contains a list view and each `Schedule` connection to `ScheduleCard` is set similar to that in the `AgendaPanel`. [Refer to _Figure 4.7.2_]

The schedule list to be reminded in the `AddressBook` is formed during every synchronisation of the master schedule list with a `Person`, as seen in _Figure 4.9.2_ below.

[source,java]
----
public class AddressBook implements ReadOnlyAddressBook {
    private void syncMasterScheduleListWith(Person person) {

         // ... merge person schedules and sort master schedule list ...

         setSchedulesToRemind();

         // ... check person schedule references ...
    }
}
----
_Figure 4.14.2: Code section in AddressBook.java_

Scheduled activities whose due date is 1 day after the date the user starts the application will be added to the `schedulesToRemind` list in `AddressBook`. This criteria is enforced in a static method in `Schedule.java`, as shown in _Figure 4.14.3_ below.

[source,java]
----
public class Schedule {
    public static boolean doesScheduleNeedReminder(Schedule schedule) {
         // Date user opens application
         LocalDate currentDate = LocalDate.now();

         String scheduleDateString = schedule.getScheduleDate().value;

         LocalDate scheduleDateToAlter = currentDate;
         // build schedule date based on String
         LocalDate scheduleDate = scheduleDateToAlter.withDayOfMonth(DateUtil.getDay(scheduleDateString))
                 .withMonth(DateUtil.getMonth(scheduleDateString))
                 .withYear(DateUtil.getYear(scheduleDateString));

         // Check if scheduled activity is one day after current date
         LocalDate dayBeforeSchedule = scheduleDate.minusDays(1);
         final boolean isYearEqual = (dayBeforeSchedule.getYear() == currentDate.getYear());
         final boolean isMonthEqual = (dayBeforeSchedule.getMonthValue() == currentDate.getMonthValue());
         final boolean isDayEqual = (dayBeforeSchedule.getDayOfMonth() == currentDate.getDayOfMonth());

         if (isYearEqual && isMonthEqual && isDayEqual) {
             return true;
         } else {
             return false;
         }
    }
}
----
_Figure 4.14.3: Code section in Schedule.java_


==== Design Considerations

**Aspect:** Content of reminder window +
**Alternative 1 (current choice)**: Show list view of schedule cards like the user agenda feature +
**Pros:** User is able to view the details of each scheduled activity. +
**Cons:** More troublesome to implement from developer's point of view. +
**Alternative 2:** Show a reminder message that there are existing activities due soon +
**Pros:** User will be alerted if reminder message is striking enough. Also easy to implement for the developer. +
**Cons:** The details of the activities due in 1 days time are not filtered out, user have to check the agenda section for more details. +
// end::reminder[]

//tag::email[]

=== Sending Email [Since v1.5]

`EmailCommand` utilise `Desktop` to launch a email platform for users to send email to multiple contacts. _Figure 4.15.1_ below indicates the sequence diagram that illsutrate how the components interact in the scenario where the user issues the email command.

image::SequenceDiagramEmail.PNG[width="600"]
_Figure 4.15.1: Component interactions for email function_

User will first have to key in indexes of the contact. `Logic` will use `AddressBookParser` class to parse user command. `ParseException` will be thrown in `EmailCommandParser` when there is detection of illegal value.By using a `Set` to store the indices inputed by user, this will prevent duplication of indicies. _Figure 4.15.2_ below indicates the parsing of user input in `EmailCommandParser`.

[source,java]
----
public class EmailCommandParser implements Parser<EmailCommand> {

        try
    {
        Set<Index> indices = new HashSet<>();
        // adding of indics to Set
    } catch(
    IllegalValueException ive)
    {
        throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EmailCommand.MESSAGE_USAGE));
    }
}

----
_Figure 4.15.2: Code section in EmailCommandParser.java_

A `Command` object will be executed by `Logic Manger`.During command excution, a filtered person list will be extracted from `Model`. The emails extracted from the filtered person list will be stored in a `recipientList` as shown in _Figure 4.15.3_ .`Desktop` class will be used to send email using `Desktop.Action.Mail` baed on `recipientList`.

[source,java]
----
public class EmailCommand extends Command {

    List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();
// ... adding of contact's email

    String recipientList = String.join(",", recipientSet);
//email logic
}
----
_Figure 4.15.3: Code section in EmailCommand.java_


Figure 4.15.4 below shows the Sequence Diagram for interactions within the Logic component for the excution of email command.

image::LogicComponentSequenceDiagramEmail.PNG[width="800"]
_Figure 4.15.4: Component interactions inside Logic Component when user issue email command_


The outcome of successful launching of email platform to send email to multiple contacts is shown in _Figure 4.15.5_.

image::EmailCommand.PNG[width="800"]
_Figure 4.15.5: Output of `EmailCommand.java` execution_


==== Design Considerations

**Aspect:** Data structure to support `EmailCommand` +
**Alternative 1 (current choice)**: Use Set for storing of user's input of indices.  +
**Pros:** Prevent duplication of indices to speed up execution of `EmailCommand`. +
**Cons:** `Set` provides random access.Two objects might be considred equal if they have the same hashcode even though they are different.  +
**Alternative 2:** Using `ArrayList` for storing of user's input of indices. +
**Pros:** List implementations are ordered as List stores element in the order they were added. +
**Cons:** Unable to detect duplicate indicies. +

---

//end::email[]

//tag::quick_start[]
=== Quick-Start Help [Since v.1.5]

At application launch, the result display box (directly beneath the command box where user inputs commands) shows a handy list
of command names and keyboard hotkey shortcuts. This reminds users of valid command keywords at a glance, and should greatly
reduce the learning curve for novice users, without affecting users who do not need it.

Since this display used to launch completely empty, placing any useful information inside was essentially a zero-cost way to
increase information displayed. As this box is a pre-emptive Help feature, it currently resides in HelpCommand (Figure 4.12.2) despite being
first called at launch, rather than by the user. However, in addition to this, a user enter `help command` to make this quick guide re-appear.

Figure 4.16.1 below shows how the result display is directly populated at launch. This allowed us to work around the limitations of result display, which usually only displays results upon user input.

[source,java]
----
// Directly raise a result to the result pane to make use of its space at application launch

raise(new NewResultAvailableEvent(COMMAND_QUICK_HELP, false));

----
_Figure 4.16.1: From WelcomeScreen.java_

[source,java]
----
// Quick-start Help contents in a String
public static final String COMMAND_QUICK_HELP_WORD = "command";
public static final String COMMAND_QUICK_HELP =
        "Quick command keyword help: " + "    F1: Full Help window;     F2: Calendar; \n"
                + AddCommand.COMMAND_WORD + " / " + AddCommand.COMMAND_ALIAS + ";     "
                + ClearCommand.COMMAND_WORD + " / " + ClearCommand.COMMAND_ALIAS + ";     "
                + CopyCommand.COMMAND_WORD + " / " + CopyCommand.COMMAND_ALIAS + ";     "
                + DeleteCommand.COMMAND_WORD + " / " + DeleteCommand.COMMAND_ALIAS + ";     "
                + CalendarCommand.COMMAND_WORD + " / " + CalendarCommand.COMMAND_ALIAS + ";     "
                + EditCommand.COMMAND_WORD + " / " + EditCommand.COMMAND_ALIAS + ";     "
                + ExitCommand.COMMAND_WORD + " / " + ExitCommand.COMMAND_ALIAS + ";     "
                + FindCommand.COMMAND_WORD + " / " + FindCommand.COMMAND_ALIAS + ";     "
                + HelpCommand.COMMAND_WORD + " / " + HelpCommand.COMMAND_ALIAS + "; \n"
                + HistoryCommand.COMMAND_WORD + " / " + HistoryCommand.COMMAND_ALIAS + ";     "
                + ListCommand.COMMAND_WORD + " / " + ListCommand.COMMAND_ALIAS + ";     "
                + RedoCommand.COMMAND_WORD + " / " + RedoCommand.COMMAND_ALIAS + ";     "
                + ScheduleCommand.COMMAND_WORD + " / " + ScheduleCommand.COMMAND_ALIAS + ";     "
                + LocateCommand.COMMAND_WORD + " / " + LocateCommand.COMMAND_ALIAS + ";     "
                + UndoCommand.COMMAND_WORD + " / " + UndoCommand.COMMAND_ALIAS + ";     "
                + BackupCommand.COMMAND_WORD + " / " + BackupCommand.COMMAND_ALIAS + ";     "
                + Country.COMMAND_WORD;

----
_Figure 4.16.2: From HelpCommand.java_

Figure 4.16.3 shows the formatted quick help list of shortcuts, commands and their aliases. Figure 4.16.4 shows this display re-appearing
after the user enters `help command`.

image::country_code demo 1.PNG[width="400"]
_Figure 4.16.3 : Quick-start help on application launch_

image::quick_help demo 1.PNG[width="400"]
_Figure 4.16.4 : Quick-start help through entering help command_

==== Design Considerations

As there is only about 3 lines' worth of space in the result display box, we needed to prioritize the most important
information to the user. Since a Command Line Interface (CLI) may have a steeper learning curve stemming from users being
unable to remember commands, this was our primary concern. However, there was insufficient space to include
the parameter inputs for each command. As we did create specific 3-line quick help for all commands, there was no urgent need to
include extra details within this quick summary of commands.

This lack of space also forced us to make full use of the space by using 4 spaces between each command listed, rather than
a new line for each command. This reasonably compact layout should also be more efficient for users to glance at, rather than
in a long straight line in either direction.

*Alternatives considered*

**Aspect:** Where to display quick-start help information +
**Alternative 1 (current choice):** Inside result display box. +
**Pros:** Space-saving and strategically placed in easy-to-view area. +
**Cons:** The help info is removed after user's first command entered. +
**Alternative 2:** In a new box or central main window area. +
**Pros:** Information can be displayed for a longer time as needed. +
**Cons:** Less convenient to look at, takes up more precious space and may not be compatible with lower resolution displays.

We could instead have placed this information in a completely new display box in the app. Although this meant that the quick
help would be available all the time, we already had significant space demands by the existing 3 other major feature panels
on the app. As such, it was unfeasible to add even more panes to the window and risk complicating the interface too.

---
//end::quick_start[]
//tag::backup[]
=== Contact Backup [Since v1.5, Windows-only]

This feature has only been tested working for Windows, and glitches may occur for other operating systems (particularly
those that use forward slashes in their file system rather than the back slash used in Windows, e.g. OS X).

Contact information is valuable, and users may want to back up their data. By providing a user-friendly backup method,
users will not have to dig around in the application directory and risk copying or deleting the wrong file.

The method is triggered with keyword `backup`, and takes in one parameter--the destination address of the backup.
As the file to back up is always `addressbook.xml`, the method can detect either a directory without the file name, or
including the file name, and perform the operation accordingly.

E.g. `backup F:\Backups` and `backup F:\Backups\addressbook.xml` perform the same operation.

[source,java]
----
    public static String parseBackup(String address) throws IllegalValueException {
        requireNonNull(address);
        if (!address.contains(BACKUP_DIR_SUFFIX)) {
            // if input ends with '\' character, concat without '\' symbol
            if (address.contains("/(?:\\)$/")) {
                return address.trim().concat(BACKUP_DIR_SUFFIX);
            } else {
                return address.trim().concat(BACKUP_DIR_SUFFIX_ALT);
            }
        }
        return address.trim();
    }
----
_Figure 4.17.1: From ParserUtil.java; Detects whether the file name exists in the input, and failing which, whether
the input ends with a back slash._

The result will be shown to the user as either a successful backup, or a failed one. As shown in Figure 4.17.2,
the input directory `String` will be queried as a `Path`; if the destination path is valid, BackupCommand will attempt
to copy and paste `addressbook.xml` into the target folder, and conclude that the attempt has failed if it detects an
IO Exception.

[source, java]
----
    @Override
    public CommandResult execute() throws CommandException {
        // source expected to stay in default directory
        Path source = Paths.get("data/addressbook.xml");
        // user defined target directory
        Path target = Paths.get(address);
        try {
            // clone addressbook into target
            Files.copy(source, target);
        } catch (IOException e1) {
            return new CommandResult(String.format(BACKUP_FAILURE_MESSAGE, address));
        }

        return new CommandResult(String.format(BACKUP_SUCCESS_MESSAGE, address));
    }
----
_Figure 4.17.2: From BackupCommand.java; Determines whether backup was successful._

As shown in Figure 4.17.3 below, a valid file path given will be accepted and the user will be notified of a successful
backup.

image::backup demo 1.PNG[width="600"]
_Figure 4.17.3 : Country name updated once a matching country code is added to phone number._

Similarly, if a path *does not exist, is read-only, or the addressbook.xml file already exists in the directory*,
the message shown in Figure 4.17.4 will be displayed instead.

image::backup demo 2.PNG[width="600"]
_Figure 4.17.4 : Copy from multiple contacts_

==== Design considerations

The Backup function makes it easier for the user to secure their valuable information, with no room for error.
As such, the implementation forbids overwriting another addressbook.xml file when writing a new one. Users must
rename or remove existing `addressbook.xml` files in the same location to avoid accidentally losing information that
they still need.

In addition, Backup should allow users to type a path without typing file name `addressbook.xml` (which is required for
the code to write to the new file copy). This is because the file name is always constant, and those who do not know
the file name or are familiar with the app can choose not to include it in the path provided, thus saving time and
preventing confusion.

*Alternatives considered*

Cloud saving and back up was attempted in early stages. We tried to use CloudRail to integrate to cloud services such
as OneDrive and Dropbox so that users can login and directly back up their address books in online storage. However,
three challenges surfaced:

. Not all users can be expected to have accounts in these cloud storage providers.
. The implementation would further complicate and clutter both user and developer ends, and cause the app to be
less responsive and possibly less user oriented.
. CloudRail did not officially support our application's use of Gradle, and integration may not be completely stable
across all devices.

**Aspect:** Where to back up the address book +
**Alternative 1 (current choice):** In a local directory on user's PC. +
**Pros:** Easy to implement, easy for the user to understand. +
**Cons:** The address book may still be lost in the event of local catastrophic failure, such as a house fire or power surge. +
**Alternative 2:** On a cloud service. +
**Pros:** Information is safe as long as user has credentials to their cloud accounts. +
**Cons:** Not all users have cloud service accounts, or know how to operate one. More difficult to implement.


As such, this idea was postponed. If these challenges are addressed, it remains a highly viable and useful alternative
that can also be used in conjunction with the current implementation.

---
//end::backup[]
=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

The logging levels used in this project include:

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

== Documentation

This section indicates the type of file we use for writing documentation.
We will be using asciidoc for writing documentation.


*Advatnages of using  asciidoc over Markdown:*

* asciidoc uses the same number of markup characters or less when compared to Markdown in nearly all cases.

* asciidoc uses a consistent formatting scheme (i.e., it has consistent patterns).

* asciidoc can handle all permutations of nested inline (and block) formatting, whereas Markdown often falls down.

* asciidoc handles cases that Markdown doesn’t, such as a proper approach to inner-word markup, source code blocks and block-level images.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.
asciidoc also supports a broader range of syntax than Markdown.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in _Figure 4.4.1_ below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 4.4.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

This section covers the various testing framework adopted for this application.
Testing is essential for quality assurance, verification and validation.
There are three ways to run tests in this application.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing

**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

This section introduce the various tools adopted for building, testing and releasing of application.

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |

|`* * *` |user |delete a person |remove entries that I no longer need

|`* * *` |user |delete multiple persons at once  |avoid going through the hassle of removing one at each time

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |user |select multiple person |perform the same command to multiple contacts at once

|`* * *` |user |update my contact |update changes to my contact's details

|`* * *` |user |store multiple information of the same kind for a contact |accommodate contacts with multiple addresses, e-mail addresses or phone numbers

|`* * *` |busy user |view my agenda for the upcoming days |prepare for my tasks in advance

|`* *` |busy user |be reminded of upcoming activities |avoid missing important events

|`* *` |user |get suggestions on the tags I have used |be consistent with the tags I use

|`* *` |user |see a sorted list of my contacts |save time and energy on my end

|`* *` |user |use shortcut to any command | find someone in my contact list easier

|`* *` |user |see a summarised list of shortcut commands |refer to the corresponding shortcut for the command I want to use

|`* *` |user |rename any field |update my relationship with contact

|`* *` |user |check the usage of commands easily |save time and energy on my end

|`* *` |user |view the location of an address on google maps |make plans to travel there

|`* *` |user |link my contact's saved email to a 'compose email page' |send an email to him/her with a click

|`* *` |user |find my contact's address on google map |locate my contact

|`* *` |user |filter my contact based on any search field |skip the process of viewing whole list of addressbook to find a contact

|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else seeing them by accident

|`* *` |user |be able to link my addressbook to my google calendar |set events and reminders related to my contacts

|`* *` |user |create a timeline with a contact |record and store activities with them

|`* *` |user |check my calendar|update of new events

|`* *` |user |send email|make immediate business communication

|`* *` |user |see my contacts' social media profile pictures |identify them more easily

|`* *` |user |write down remarks for a contact |record specific information about the contact

|`* *` |user |to create new task|keep track on ongoing task and stay on track

|`*` |user with many persons in the address book |sort persons by name |locate a person easily

|`*` |user |choose the colour for my contact's tag |differentiate contact's with different tags just by looking at them

|`*` |user |sort persons by birthday |view whose birthdays are in the upcoming months

|`*` |forgeful user |key in a contact's birthday and be reminded about it when the time comes |wish him/her happy birthday

|`*` |careless user |be prompted to confirm my input whenever I add a person |avoid adding a person with the wrong details

|=======================================================================

{More to be added}

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Contag` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Schedule an activity
=== Use case: Schedule an activity

*MSS*

1.  User requests to list persons
2.  ConTag shows a list of persons
3.  User requests to schedule an activity to a specific person in the list
4.  ConTag successfully schedules activity to contact
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index or format is invalid.
+
[none]
** 3a1. ConTag shows an error message.
+
Use case resumes at step 2.

=== Use case: Delete persons
*MSS*

1.  User requests to list persons
2.  ConTag shows a list of persons
3.  User requests to delete a specific person in the list
4.  ConTag deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. ConTag shows an error message.
+
Use case resumes at step 2.

=== Use case: Rename existing tag
#Pre-condition :The identitifed tag exists in  ConTag
**MSS**

1. User requests to list persons
2. ConTagshows a list of persons
3. User requests to rename the tag and key in the new input
4. ConTagprompts user to confirm the changes
5. User confirms changes
6. ConTag successfully replaces the name of the existing tag to the newer version
+
Use case ends.

=== Use case: Search by phone
#Pre-condition :The identitifed phone exist in ConTag
**MSS**

1. User requests to list persons
2. ConTag shows a list of persons
3. User requests to search for phone number by inputting 4 or 8 digits
4. ConTag successfully find the persons with matching phone numbers
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given phone number is invalid.
+
[none]
** 3a1. ConTag shows an error message.
+
Use case resumes at step 2.

{More to be added}

[appendix]
== Non Functional Requirements

The following are some of the non-functional requirements for the project:

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Respond time should be less than 10s
.  Should be able to automatically create a backup file for the contacts data stored
.  The project is expected to adhere to a schedule that delivers a feature set every week

{More to be added}

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[private-contact-detail]]
Private contact detail

....
A contact detail that is not meant to be shared with others
....


[[CI]]
CI

....
Continuous Integration (CI) is the process of automating the build and testing of
code every time a team member commits changes to version control
....

[[gradle]]
Gradle

....
Gradle is an open source build automation system that builds upon\
the concepts of Apache Ant and Apache Maven
....

[[JUnit]]
JUnit

....
JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit
architecture for unit testing frameworks
....

[[JavaFX]]
JavaFX

....
JavaFX is a software platform for creating and delivering desktop applications,
as well as rich internet applications (RIAs) that can run across a wide variety of devices
....

[[GUI]]
GUI

....
A graphical user interface (GUI) is a human-computer interface that uses windows,
icons and menus and  can be manipulated by a mouse.
....

[[xml]]
xml

....
XML is a file extension for an Extensible Markup Language (XML) file format.
....
