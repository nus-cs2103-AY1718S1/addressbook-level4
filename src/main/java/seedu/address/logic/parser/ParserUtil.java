package seedu.address.logic.parser;

import static java.util.Objects.requireNonNull;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.kordamp.ikonli.Ikon;
import org.kordamp.ikonli.feather.Feather;

import seedu.address.commons.core.index.Index;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.StringUtil;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.AliasCommand;
import seedu.address.logic.commands.ClearCommand;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.ExitCommand;
import seedu.address.logic.commands.FindCommand;
import seedu.address.logic.commands.HelpCommand;
import seedu.address.logic.commands.HistoryCommand;
import seedu.address.logic.commands.ListCommand;
import seedu.address.logic.commands.MusicCommand;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.SelectCommand;
import seedu.address.logic.commands.UnaliasCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.parser.exceptions.ParseException;
import seedu.address.model.Aliases;
import seedu.address.model.UserPrefs;
import seedu.address.model.person.Address;
import seedu.address.model.person.Avatar;
import seedu.address.model.person.Email;
import seedu.address.model.person.Name;
import seedu.address.model.person.Phone;
import seedu.address.model.person.Remark;
import seedu.address.model.tag.Tag;

/**
 * Contains utility methods used for parsing strings in the various *Parser classes.
 * {@code ParserUtil} contains methods that take in {@code Optional} as parameters. However, it goes against Java's
 * convention (see https://stackoverflow.com/a/39005452) as {@code Optional} should only be used a return type.
 * Justification: The methods in concern receive {@code Optional} return values from other methods as parameters and
 * return {@code Optional} values based on whether the parameters were present. Therefore, it is redundant to unwrap the
 * initial {@code Optional} before passing to {@code ParserUtil} as a parameter and then re-wrap it into an
 * {@code Optional} return value inside {@code ParserUtil} methods.
 */
public class ParserUtil {

    public static final String MESSAGE_INVALID_INDEX = "Index is not a non-zero unsigned integer.";
    public static final String MESSAGE_INSUFFICIENT_PARTS = "Number of parts must be more than 1.";

    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    //@@author goweiwen
    private static final Map<String, Ikon> Icons = new HashMap<>();
    static {
        Icons.put(MusicCommand.COMMAND_WORD, Feather.FTH_PLAY);
        Icons.put(AddCommand.COMMAND_WORD, Feather.FTH_PLUS);
        Icons.put(AliasCommand.COMMAND_WORD, Feather.FTH_LINK);
        Icons.put(UnaliasCommand.COMMAND_WORD, Feather.FTH_CROSS);
        Icons.put(EditCommand.COMMAND_WORD, Feather.FTH_FILE_ADD);
        Icons.put(SelectCommand.COMMAND_WORD, Feather.FTH_HEAD);
        Icons.put(DeleteCommand.COMMAND_WORD, Feather.FTH_TRASH);
        Icons.put(ClearCommand.COMMAND_WORD, Feather.FTH_CROSS);
        Icons.put(FindCommand.COMMAND_WORD, Feather.FTH_SEARCH);
        Icons.put(ListCommand.COMMAND_WORD, Feather.FTH_PAPER);
        Icons.put(HistoryCommand.COMMAND_WORD, Feather.FTH_CLOCK);
        Icons.put(ExitCommand.COMMAND_WORD, Feather.FTH_POWER);
        Icons.put(HelpCommand.COMMAND_WORD, Feather.FTH_HELP);
        Icons.put(UndoCommand.COMMAND_WORD, Feather.FTH_ARROW_LEFT);
        Icons.put(RedoCommand.COMMAND_WORD, Feather.FTH_ARROW_RIGHT);
    }
    //@@author

    /**
     * Parses {@code oneBasedIndex} into an {@code Index} and returns it. Leading and trailing whitespaces will be
     * trimmed.
     * @throws IllegalValueException if the specified index is invalid (not non-zero unsigned integer).
     */
    public static Index parseIndex(String oneBasedIndex) throws IllegalValueException {
        String trimmedIndex = oneBasedIndex.trim();
        if (!StringUtil.isNonZeroUnsignedInteger(trimmedIndex)) {
            throw new IllegalValueException(MESSAGE_INVALID_INDEX);
        }
        return Index.fromOneBased(Integer.parseInt(trimmedIndex));
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        requireNonNull(name);
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> phone} into an {@code Optional<Phone>} if {@code phone} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Phone> parsePhone(Optional<String> phone) throws IllegalValueException {
        requireNonNull(phone);
        return phone.isPresent() ? Optional.of(new Phone(phone.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> address} into an {@code Optional<Address>} if {@code address} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Address> parseAddress(Optional<String> address) throws IllegalValueException {
        requireNonNull(address);
        return address.isPresent() ? Optional.of(new Address(address.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Email> parseEmail(Optional<String> email) throws IllegalValueException {
        requireNonNull(email);
        return email.isPresent() ? Optional.of(new Email(email.get())) : Optional.empty();
    }
    //@@author hanselblack
    /**
     * Parses a {@code Optional<String> remark} into an {@code Optional<Remark>} if {@code remark} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Remark> parseRemark(Optional<String> remark) throws IllegalValueException {
        requireNonNull(remark);
        return remark.isPresent() ? Optional.of(new Remark(remark.get())) : Optional.of(new Remark(""));
    }
    /**
     * Parses a {@code Optional<String> remark} into an {@code Optional<Remark>} if {@code remark} is present.
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Remark> editParseRemark(Optional<String> remark) throws IllegalValueException {
        requireNonNull(remark);
        return remark.isPresent() ? Optional.of(new Remark(remark.get())) : Optional.empty();
    }
    //@@author

    /**
     * Parses a {@code Optional<String> avatarFilePath} into an {@code Optional<Avatar>}
     * if {@code avatarFilePath} is present.
     * If not present, creates an avatar with null value into {@code Optional<Avatar>}
     * See header comment of this class regarding the use of {@code Optional} parameters.
     */
    public static Optional<Avatar> parseAvatar(Optional<String> avatarFilePath) throws IllegalValueException {
        requireNonNull(avatarFilePath);
        return avatarFilePath.isPresent()
                ? Optional.of(Avatar.readAndCreateAvatar(avatarFilePath.get())) : Optional.of(new Avatar(null));
    }

    /**
     * Parses {@code Collection<String> tags} into a {@code Set<Tag>}.
     */
    public static Set<Tag> parseTags(Collection<String> tags) throws IllegalValueException {
        requireNonNull(tags);
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return tagSet;
    }

    //@@author goweiwen
    /**
     * Parses {@code String command} and returns itself if it is a valid command.
     */
    public static String parseCommand(String command) {
        requireNonNull(command);
        switch (command) {
        case AddCommand.COMMAND_WORD:
        case AliasCommand.COMMAND_WORD:
        case EditCommand.COMMAND_WORD:
        case SelectCommand.COMMAND_WORD:
        case DeleteCommand.COMMAND_WORD:
        case ClearCommand.COMMAND_WORD:
        case FindCommand.COMMAND_WORD:
        case ListCommand.COMMAND_WORD:
        case HistoryCommand.COMMAND_WORD:
        case ExitCommand.COMMAND_WORD:
        case HelpCommand.COMMAND_WORD:
        case UndoCommand.COMMAND_WORD:
        case RedoCommand.COMMAND_WORD:
            return command;
        default:
            return null;
        }
    }

    /**
     * Parses {@code String command} and returns the corresponding {@code Ikon icon}
     * if valid.
     */
    public static Ikon parseIconCode(String command) {
        requireNonNull(command);
        return Icons.get(command);
    }

    /**
     * Parses {@code String userInput} and returns an array of {commandWord, arguments} if valid.
     */
    public static String[] parseCommandAndArguments(String userInput) throws ParseException {
        requireNonNull(userInput);

        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        String commandWord = matcher.group("commandWord");
        String arguments = matcher.group("arguments");

        Aliases aliases = UserPrefs.getInstance().getAliases();
        String aliasedCommand = aliases.getCommand(commandWord);
        if (aliasedCommand != null) {
            final Matcher aliasMatcher = BASIC_COMMAND_FORMAT.matcher(aliasedCommand.trim());
            if (!aliasMatcher.matches()) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }

            commandWord = aliasMatcher.group("commandWord");
            arguments = aliasMatcher.group("arguments") + " " + arguments;
        }

        return new String[] {commandWord, arguments};
    }

}
