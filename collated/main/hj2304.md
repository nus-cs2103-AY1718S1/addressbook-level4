# hj2304
###### \java\seedu\address\model\ModelManager.java
``` java
    public void deleteTag(String str) {
        if (addressBook.removeTag(str)) {
            indicateAddressBookChanged();
        }
    }

```
# hj2304
###### \java\seedu\address\logic\commands\AddEventTagCommand.java
``` java
/**
 * Adds a tag to persons who are in an event if the event can be scheduled.
 */
public class AddEventTagCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "addEventTag";
    public static final String COMMAND_ALIAS = "event";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": schedules an event in the time specified \n"
            + "Parameters: EventName StartTime EndTime Location "
            + "Indices separated by spaces (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + "n/Meeting d/Monday st/1000 et/1300 loc/School persons/1 2 5 7 8";

    public static final String MESSAGE_ARRANGE_PERSON_SUCCESS = "Event Tag successfully added!";
    public static final String MESSAGE_ARRANGE_PERSON_FAILURE = "Not everyone can make it; "
            + "try using the 'arrange' command to look for common timings";

    private final Index[] listOfIndex;
    private final Day day;
    private final Time startTime;
    private final Time endTime;
    private TreeSet<Integer> timeToClear;
    private final Tag event;

    public AddEventTagCommand(Day day, Time startTime, Time endTime,
                              Index[] listOfIndex, Tag event) throws IllegalValueException {
        this.listOfIndex = listOfIndex;
        this.day = day;
        this.startTime = startTime;
        this.endTime = endTime;
        Slot slot = new Slot(day, startTime, endTime);
        timeToClear = slot.getBusyTime();
        this.event = event;
    }

    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();
        boolean check = model.checkMeetingTime(listOfIndex, day.getDay(), startTime.getTime(), endTime.getTime());
        if (!check) {
            return new CommandResult(MESSAGE_ARRANGE_PERSON_FAILURE);
        } else {
            try {
                for (int i = 0; i < listOfIndex.length; i++) {
                    model.clearScheduleForPerson(listOfIndex[i].getZeroBased(), timeToClear);
                    model.addEventToPerson(listOfIndex[i].getZeroBased(), event);
                }
            } catch (PersonNotFoundException pnfe) {
                assert false : "The target person cannot be missing";
            }
            return new CommandResult(MESSAGE_ARRANGE_PERSON_SUCCESS);

        }
    }
}

```
###### \java\seedu\address\logic\parser\AddEventTagCommandParser.java
``` java

/**
 * Parses the arguments for AddEventTagFunction and creates a new AddEventTagCommand
 */
public class AddEventTagCommandParser implements Parser<AddEventTagCommand> {
    /**
     * Parses the given {@code String} of arguments in the context of the AddEventTagCommand
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddEventTagCommand parse(String args) throws ParseException {

        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(args, PREFIX_NAME, PREFIX_DAY, PREFIX_START_TIME,
                PREFIX_END_TIME, PREFIX_LOC, PREFIX_PERSONS);

        if (!arePrefixesPresent(argMultimap, PREFIX_NAME, PREFIX_DAY, PREFIX_START_TIME, PREFIX_END_TIME,
                PREFIX_LOC, PREFIX_PERSONS)) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddEventTagCommand.MESSAGE_USAGE));
        }

        try {
            String name = argMultimap.getValue(PREFIX_NAME).get();
            String location = argMultimap.getValue(PREFIX_LOC).get();
            Day day = ParserUtil.parseDay(argMultimap.getValue(PREFIX_DAY)).get();
            Time startTime = ParserUtil.parseTime(argMultimap.getValue(PREFIX_START_TIME)).get();
            Time endTime = ParserUtil.parseTime(argMultimap.getValue(PREFIX_END_TIME)).get();
            String indices = argMultimap.getValue(PREFIX_PERSONS).get();
            Index[] listIndex = ParserUtil.parseIndexArr(indices);
            String eventStr = name + "on" + day.toString() + "at" + location;
            Tag event = new Tag(eventStr);
            return new AddEventTagCommand(day, startTime, endTime, listIndex, event);
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage(), ive);
        }
    }

    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    private static boolean arePrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }
}
```
###### \java\seedu\address\model\AddressBook.java
``` java
    /**
     * Checks Meeting Time based on the list of Index.
     */
    public boolean checkMeetingTime(Index[] listOfIndex, int day, int start, int end) {
        boolean res = true;
        TreeSet<Integer> satisfiedTimeSet = new TreeSet<>();
        boolean started = false;
        boolean ended = false;
        for (int k = 0; k < PossibleTimes.TIMES.length; k++) {
            if (PossibleTimes.TIMES[k] == start) {
                started = true;
            }
            if (PossibleTimes.TIMES[k] == end) {
                ended = true;
            }
            if (started && !ended) {
                satisfiedTimeSet.add(day * PossibleDays.DAY_COEFFICIENT + PossibleTimes.TIMES[k]);
            }
            if (ended) {
                break;
            }
        }
        if (!started || !ended) {
            res = false;
        }
        for (int j = 0; j < listOfIndex.length; j++) {
            if (!res) {
                break;
            }
            Iterator<Integer> iterator = satisfiedTimeSet.iterator();
            Schedule currentSchedule = getPersonList().get(listOfIndex[j].getZeroBased()).getSchedule();
            while (iterator.hasNext()) {
                Integer timeNumber = iterator.next();
                if (!currentSchedule.containsTimeNumber(timeNumber)) {
                    res = false;
                    break;
                }
            }
        }
        return res;
    }

    public void addEventToPerson(Integer index, Tag event) {
        persons.addEventTag(index, event);
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public void addEventToPerson(Integer index, Tag event) {
        addressBook.addEventToPerson(index, event);
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    /**
     * Tests meeting time.
     */
    @Override
    public boolean checkMeetingTime(Index[] listOfIndex, int day, int start, int end) {
        return addressBook.checkMeetingTime(listOfIndex, day, start, end);
    }

```
###### \java\seedu\address\model\person\Person.java
``` java
    /**
     * adds an eventTag to the person
     * @param event
     */
    public void addEventTag(Tag event) {
        Set<Tag> tags = getTags();
        Set<Tag> tagSet = new HashSet<Tag>();
        for (Tag t : tags) {
            tagSet.add(t);
        }
        tagSet.add(event);
        setTags(tagSet);
    }

```
###### \java\seedu\address\model\person\UniquePersonList.java
``` java
    public void addEventTag(Integer toAdd, Tag event) {
        internalList.get(toAdd).addEventTag(event);
    }
}
```

