# tby1994
###### /java/guitests/guihandles/MainWindowHandle.java
``` java
    public MainWindowHandle(Stage stage) {
        super(stage);

        personListPanel = new PersonListPanelHandle(getChildNode(PersonListPanelHandle.PERSON_LIST_VIEW_ID));
        resultDisplay = new ResultDisplayHandle(getChildNode(ResultDisplayHandle.RESULT_DISPLAY_ID));
        commandBox = new CommandBoxHandle(getChildNode(CommandBoxHandle.COMMAND_INPUT_FIELD_ID));
        statusBarFooter = new StatusBarFooterHandle(getChildNode(StatusBarFooterHandle.STATUS_BAR_PLACEHOLDER));
        mainMenu = new MainMenuHandle(getChildNode(MainMenuHandle.MENU_BAR_ID));
        browserPanel = new BrowserPanelHandle(getChildNode(BrowserPanelHandle.BROWSER_ID));
        taskListPanelHandle = new TaskListPanelHandle(getChildNode(TaskListPanelHandle.TASK_LIST_VIEW_ID));
    }
```
###### /java/guitests/guihandles/MainWindowHandle.java
``` java
    public TaskListPanelHandle getTaskListPanel() {
        return taskListPanelHandle;
    }
}
```
###### /java/guitests/guihandles/TaskCardHandle.java
``` java
/**
 * Provides a handle to a person card in the person list panel.
 */
public class TaskCardHandle extends NodeHandle<Node> {
    private static final String ID_FIELD_ID = "#id";
    private static final String DESCRIPTION_FIELD_ID = "#description";
    private static final String STARTDATE_FIELD_ID = "#startDate";
    private static final String DEADLINE_FIELD_ID = "#deadline";

    private final Label idLabel;
    private final Label descriptionLabel;
    private final Label startDateLabel;
    private final Label deadlineLabel;

    public TaskCardHandle(Node cardNode) {
        super(cardNode);

        this.idLabel = getChildNode(ID_FIELD_ID);
        this.descriptionLabel = getChildNode(DESCRIPTION_FIELD_ID);
        this.startDateLabel = getChildNode(STARTDATE_FIELD_ID);
        this.deadlineLabel = getChildNode(DEADLINE_FIELD_ID);
    }


    public String getId() {
        return idLabel.getText();
    }

    public String getDescription() {
        return descriptionLabel.getText();
    }

    public String getStartDate() {
        return startDateLabel.getText();
    }

    public String getDeadline() {
        return deadlineLabel.getText();
    }
}
```
###### /java/guitests/guihandles/TaskListPanelHandle.java
``` java
/**
 * Provides a handle for {@code TaskListPanel} containing the list of {@code TaskCard}.
 */
public class TaskListPanelHandle extends NodeHandle<ListView<TaskCard>> {
    public static final String TASK_LIST_VIEW_ID = "#taskCardListView";

    private Optional<TaskCard> lastRememberedSelectedTaskCard;

    public TaskListPanelHandle(ListView<TaskCard> taskListPanelNode) {
        super(taskListPanelNode);
    }

    /**
     * Returns a handle to the selected {@code TaskCardHandle}.
     * A maximum of 1 item can be selected at any time.
     * @throws AssertionError if no card is selected, or more than 1 card is selected.
     */
    public TaskCardHandle getHandleToSelectedCard() {
        List<TaskCard> taskList = getRootNode().getSelectionModel().getSelectedItems();

        if (taskList.size() != 1) {
            throw new AssertionError("Task list size expected 1.");
        }

        return new TaskCardHandle(taskList.get(0).getRoot());
    }

    /**
     * Returns the index of the selected card.
     */
    public int getSelectedTaskCardIndex() {
        return getRootNode().getSelectionModel().getSelectedIndex();
    }

    /**
     * Returns true if a card is currently selected.
     */
    public boolean isAnyCardSelected() {
        List<TaskCard> selectedCardsList = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedCardsList.size() > 1) {
            throw new AssertionError("Card list size expected 0 or 1.");
        }

        return !selectedCardsList.isEmpty();
    }

    /**
     * Navigates the listview to display and select the task.
     */
    public void navigateToTask(ReadOnlyTask task) {
        List<TaskCard> cards = getRootNode().getItems();
        Optional<TaskCard> matchingCard = cards.stream().filter(card -> card.task.equals(task)).findFirst();

        if (!matchingCard.isPresent()) {
            throw new IllegalArgumentException("Task does not exist.");
        }

        guiRobot.interact(() -> {
            getRootNode().scrollTo(matchingCard.get());
            getRootNode().getSelectionModel().select(matchingCard.get());
        });
        guiRobot.pauseForHuman();
    }

    /**
     * Returns the task card handle of a task associated with the {@code index} in the list.
     */
    public TaskCardHandle getTaskCardHandle(int index) {
        return getTaskCardHandle(getRootNode().getItems().get(index).task);
    }

    /**
     * Returns the {@code TaskCardHandle} of the specified {@code task} in the list.
     */
    public TaskCardHandle getTaskCardHandle(ReadOnlyTask task) {
        Optional<TaskCardHandle> handle = getRootNode().getItems().stream()
                .filter(card -> card.task.equals(task))
                .map(card -> new TaskCardHandle(card.getRoot()))
                .findFirst();
        return handle.orElseThrow(() -> new IllegalArgumentException("Task does not exist."));
    }

    /**
     * Selects the {@code TaskCard} at {@code index} in the list.
     */
    public void select(int index) {
        getRootNode().getSelectionModel().select(index);
    }

    /**
     * Remembers the selected {@code TaskCard} in the list.
     */
    public void rememberSelectedTaskCard() {
        List<TaskCard> selectedItems = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedItems.size() == 0) {
            lastRememberedSelectedTaskCard = Optional.empty();
        } else {
            lastRememberedSelectedTaskCard = Optional.of(selectedItems.get(0));
        }
    }

    /**
     * Returns true if the selected {@code TaskCard} is different from the value remembered by the most recent
     * {@code rememberSelectedTaskCard()} call.
     */
    public boolean isSelectedTaskCardChanged() {
        List<TaskCard> selectedItems = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedItems.size() == 0) {
            return lastRememberedSelectedTaskCard.isPresent();
        } else {
            return !lastRememberedSelectedTaskCard.isPresent()
                    || !lastRememberedSelectedTaskCard.get().equals(selectedItems.get(0));
        }
    }

    /**
     * Returns the size of the list.
     */
    public int getListSize() {
        return getRootNode().getItems().size();
    }
}
```
###### /java/guitests/HelpWindowTest.java
``` java
    @Test
    public void openHelpWindow() {
        //use accelerator
        getCommandBox().click();
        getMainMenu().openHelpWindowUsingAccelerator();
        assertHelpWindowOpen();

        getResultDisplay().click();
        getMainMenu().openHelpWindowUsingAccelerator();
        assertHelpWindowOpen();

        getPersonListPanel().click();
        getMainMenu().openHelpWindowUsingAccelerator();
        assertHelpWindowOpen();

        getTaskListPanel().click();
        getMainMenu().openHelpWindowUsingAccelerator();
        assertHelpWindowOpen();

        getBrowserPanel().click();
        getMainMenu().openHelpWindowUsingAccelerator();
        assertHelpWindowNotOpen();

        //use menu button
        getMainMenu().openHelpWindowUsingMenu();
        assertHelpWindowOpen();

        //use command box
        runCommand(HelpCommand.COMMAND_WORD);
        assertHelpWindowOpen();
    }
```
###### /java/seedu/address/logic/commands/AddCommandTest.java
``` java
        @Override
        public void changeCommandMode(String mode) throws IllegalValueException {
            fail("This method should not be called");
        }

        @Override
        public CommandMode getCommandMode() {
            fail("This method should not be called ");
            return null;
        }
```
###### /java/seedu/address/logic/commands/FindTaskCommandTest.java
``` java
/**
 * Contains integration tests (interaction with the Model) for {@code FindTaskCommand}.
 */
public class FindTaskCommandTest {
    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs());

    @Test
    public void equals() {
        TaskContainsKeywordsPredicate firstPredicate =
            new TaskContainsKeywordsPredicate(Collections.singletonList("first"));
        TaskContainsKeywordsPredicate secondPredicate =
            new TaskContainsKeywordsPredicate(Collections.singletonList("second"));

        FindTaskCommand findFirstCommand = new FindTaskCommand(firstPredicate);
        FindTaskCommand findSecondCommand = new FindTaskCommand(secondPredicate);

        // same object -> returns true
        assertTrue(findFirstCommand.equals(findFirstCommand));

        // same values -> returns true
        FindTaskCommand findFirstCommandCopy = new FindTaskCommand(firstPredicate);
        assertTrue(findFirstCommand.equals(findFirstCommandCopy));

        // different types -> returns false
        assertFalse(findFirstCommand.equals(1));

        // null -> returns false
        assertFalse(findFirstCommand.equals(null));

        // different task -> returns false
        assertFalse(findFirstCommand.equals(findSecondCommand));
    }

    @Test
    public void executeZeroKeywordsNoTaskFound() {
        String expectedMessage = String.format(MESSAGE_TASK_LISTED_OVERVIEW, 0);
        FindTaskCommand command = prepareCommand(" ");
        assertCommandSuccess(command, expectedMessage, Collections.emptyList());
    }

    @Test
    public void executeMultipleKeywordsMultipleTasksFound() {
        String expectedMessage = String.format(MESSAGE_TASK_LISTED_OVERVIEW, 4);
        FindTaskCommand command = prepareCommand("Finish gym online");
        assertCommandSuccess(command, expectedMessage, Arrays.asList(ASSIGNMENT, QUIZ, GYM, PERSONAL_PROJECT));
    }

```
###### /java/seedu/address/logic/commands/ListTasksCommandTest.java
``` java
/**
 * Contains integration tests (interaction with the Model) and unit tests for ListTasksCommand.
 */
public class ListTasksCommandTest {

    private Model model;
    private Model expectedModel;
    private ListTasksCommand listTasksCommand;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs());
        expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());

        listTasksCommand = new ListTasksCommand();
        listTasksCommand.setData(model, new CommandHistory(), new UndoRedoStack());
    }

    @Test
    public void execute_listIsNotFiltered_showsSameList() {
        assertCommandSuccess(listTasksCommand, model, ListTasksCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void execute_listIsFiltered_showsEverything() {
        showFirstTaskOnly(model);
        assertCommandSuccess(listTasksCommand, model, ListTasksCommand.MESSAGE_SUCCESS, expectedModel);
    }
}
```
###### /java/seedu/address/logic/commands/SelectTaskCommandTest.java
``` java
/**
 * Contains integration tests (interaction with the Model) for {@code SelectTaskCommand}.
 */
public class SelectTaskCommandTest {
    @Rule
    public final EventsCollectorRule eventsCollectorRule = new EventsCollectorRule();

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs());
    }

    @Test
    public void execute_validIndexUnfilteredList_success() {
        Index lastTaskIndex = Index.fromOneBased(model.getFilteredTaskList().size());

        assertExecutionSuccess(INDEX_FIRST_TASK);
        assertExecutionSuccess(INDEX_THIRD_TASK);
        assertExecutionSuccess(lastTaskIndex);
    }

    @Test
    public void execute_invalidIndexUnfilteredList_failure() {
        Index outOfBoundsIndex = Index.fromOneBased(model.getFilteredTaskList().size() + 1);

        assertExecutionFailure(outOfBoundsIndex, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void execute_validIndexFilteredList_success() {
        showFirstTaskOnly(model);

        assertExecutionSuccess(INDEX_FIRST_TASK);
    }

    @Test
    public void execute_invalidIndexFilteredList_failure() {
        showFirstTaskOnly(model);

        Index outOfBoundsIndex = INDEX_SECOND_TASK;
        // ensures that outOfBoundIndex is still in bounds of address book list
        assertTrue(outOfBoundsIndex.getZeroBased() < model.getAddressBook().getTaskList().size());

        assertExecutionFailure(outOfBoundsIndex, Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void equals() {
        SelectTaskCommand selectFirstCommand = new SelectTaskCommand(INDEX_FIRST_TASK);
        SelectTaskCommand selectSecondCommand = new SelectTaskCommand(INDEX_SECOND_TASK);

        // same object -> returns true
        assertTrue(selectFirstCommand.equals(selectFirstCommand));

        // same values -> returns true
        SelectTaskCommand selectFirstCommandCopy = new SelectTaskCommand(INDEX_FIRST_TASK);
        assertTrue(selectFirstCommand.equals(selectFirstCommandCopy));

        // different types -> returns false
        assertFalse(selectFirstCommand.equals(1));

        // null -> returns false
        assertFalse(selectFirstCommand.equals(null));

        // different task -> returns false
        assertFalse(selectFirstCommand.equals(selectSecondCommand));
    }

    /**
     * Executes a {@code SelectTaskCommand} with the given {@code index}, and checks that {@code JumpToListRequestEvent}
     * is raised with the correct index.
     */
    private void assertExecutionSuccess(Index index) {
        SelectTaskCommand selectCommand = prepareCommand(index);

        try {
            CommandResult commandResult = selectCommand.execute();
            assertEquals(String.format(SelectTaskCommand.MESSAGE_SELECT_TASK_SUCCESS, index.getOneBased()),
                commandResult.feedbackToUser);
        } catch (CommandException ce) {
            throw new IllegalArgumentException("Execution of command should not fail.", ce);
        }

        JumpToTaskListRequestEvent lastEvent =
            (JumpToTaskListRequestEvent) eventsCollectorRule.eventsCollector.getMostRecent();
        assertEquals(index, Index.fromZeroBased(lastEvent.targetIndex));
    }

    /**
     * Executes a {@code SelectTaskCommand} with the given {@code index}, and checks that a {@code CommandException}
     * is thrown with the {@code expectedMessage}.
     */
    private void assertExecutionFailure(Index index, String expectedMessage) {
        SelectTaskCommand selectCommand = prepareCommand(index);

        try {
            selectCommand.execute();
            fail("The expected CommandException was not thrown.");
        } catch (CommandException ce) {
            assertEquals(expectedMessage, ce.getMessage());
            assertTrue(eventsCollectorRule.eventsCollector.isEmpty());
        }
    }

    /**
     * Returns a {@code SelectTaskCommand} with parameters {@code index}.
     */
    private SelectTaskCommand prepareCommand(Index index) {
        SelectTaskCommand selectCommand = new SelectTaskCommand(index);
        selectCommand.setData(model, new CommandHistory(), new UndoRedoStack());
        return selectCommand;
    }
}
```
###### /java/seedu/address/logic/parser/AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_add() throws Exception {
        Person person = new PersonBuilder().build();
        AddCommand command = (AddCommand) parser.parseCommand(PersonUtil.getAddCommand(person), MODE_ADDRESS_BOOK);
        assertEquals(new AddCommand(person), command);
    }

    @Test
    public void parseCommand_clear() throws Exception {
        assertTrue(parser.parseCommand(ClearCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof ClearCommand);
        assertTrue(parser.parseCommand(ClearCommand.COMMAND_WORD + " 3", MODE_ADDRESS_BOOK)
            instanceof ClearCommand);
    }

    @Test
    public void parseCommand_delete() throws Exception {
        DeleteCommand command = (DeleteCommand) parser.parseCommand(
                DeleteCommand.COMMAND_WORD + " " + INDEX_FIRST_PERSON.getOneBased(), MODE_ADDRESS_BOOK);
        assertEquals(new DeleteCommand(INDEX_FIRST_PERSON), command);
    }

    @Test
    public void parseCommand_edit() throws Exception {
        Person person = new PersonBuilder().build();
        EditPersonDescriptor descriptor = new EditPersonDescriptorBuilder(person).build();
        EditCommand command = (EditCommand) parser.parseCommand(EditCommand.COMMAND_WORD + " "
                + INDEX_FIRST_PERSON.getOneBased() + " " + PersonUtil.getPersonDetails(person), MODE_ADDRESS_BOOK);
        assertEquals(new EditCommand(INDEX_FIRST_PERSON, descriptor), command);
    }

    @Test
    public void parseCommand_exit() throws Exception {
        assertTrue(parser.parseCommand(ExitCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof ExitCommand);
        assertTrue(parser.parseCommand(ExitCommand.COMMAND_WORD + " 3", MODE_ADDRESS_BOOK) instanceof ExitCommand);
    }

    @Test
    public void parseCommand_find() throws Exception {
        List<String> keywords = Arrays.asList("foo", "bar", "baz");
        FindCommand command = (FindCommand) parser.parseCommand(
                FindCommand.COMMAND_WORD + " " + keywords.stream().collect(Collectors.joining(" ")),
                MODE_ADDRESS_BOOK);
        assertEquals(new FindCommand(new PersonContainsKeywordsPredicate(keywords)), command);

    }

    @Test
    public void parseCommand_help() throws Exception {
        assertTrue(parser.parseCommand(HelpCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof HelpCommand);
        assertTrue(parser.parseCommand(HelpCommand.COMMAND_WORD + " 3", MODE_ADDRESS_BOOK)
            instanceof HelpCommand);
    }

    @Test
    public void parseCommand_history() throws Exception {
        assertTrue(parser.parseCommand(HistoryCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof HistoryCommand);
        assertTrue(parser.parseCommand(HistoryCommand.COMMAND_WORD + " 3", MODE_ADDRESS_BOOK)
            instanceof HistoryCommand);

        try {
            parser.parseCommand("histories", MODE_ADDRESS_BOOK);
            fail("The expected ParseException was not thrown.");
        } catch (ParseException pe) {
            assertEquals(MESSAGE_UNKNOWN_COMMAND, pe.getMessage());
        }
    }

    @Test
    public void parseCommand_list() throws Exception {
        assertTrue(parser.parseCommand(ListCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof ListCommand);
        assertTrue(parser.parseCommand(ListCommand.COMMAND_WORD + " 3", MODE_ADDRESS_BOOK) instanceof ListCommand);
    }

    @Test
    public void parseCommand_select() throws Exception {
        SelectCommand command = (SelectCommand) parser.parseCommand(
                SelectCommand.COMMAND_WORD + " " + INDEX_FIRST_PERSON.getOneBased(), MODE_ADDRESS_BOOK);
        assertEquals(new SelectCommand(INDEX_FIRST_PERSON), command);
    }

    @Test
    public void parseCommand_redoCommandWord_returnsRedoCommand() throws Exception {
        assertTrue(parser.parseCommand(RedoCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof RedoCommand);
        assertTrue(parser.parseCommand("redo 1", MODE_ADDRESS_BOOK) instanceof RedoCommand);
    }

    @Test
    public void parseCommand_tagCommand_returnsTagCommand() throws Exception {
        String tag = "foo";
        Set<Tag> tagList = SampleDataUtil.getTagSet(tag);
        Index[] indices = {INDEX_FIRST_PERSON, INDEX_SECOND_PERSON};
        TagCommand command =
                (TagCommand) parser.parseCommand(PersonUtil.getTagCommand(indices, tag), MODE_ADDRESS_BOOK);
        assertEquals(new TagCommand(indices, tagList), command);
    }

    @Test
    public void parseCommand_undoCommandWord_returnsUndoCommand() throws Exception {
        assertTrue(parser.parseCommand(UndoCommand.COMMAND_WORD, MODE_ADDRESS_BOOK) instanceof UndoCommand);
        assertTrue(parser.parseCommand("undo 3", MODE_ADDRESS_BOOK) instanceof UndoCommand);
    }

    @Test
    public void parseCommand_unrecognisedInput_throwsParseException() throws Exception {
        thrown.expect(ParseException.class);
        thrown.expectMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        parser.parseCommand("", MODE_ADDRESS_BOOK);
    }

    @Test
    public void parseCommand_unknownCommand_throwsParseException() throws Exception {
        thrown.expect(ParseException.class);
        thrown.expectMessage(MESSAGE_UNKNOWN_COMMAND);
        parser.parseCommand("unknownCommand", MODE_ADDRESS_BOOK);
    }
}
```
###### /java/seedu/address/logic/parser/ChangeModeCommandParserTest.java
``` java
public class ChangeModeCommandParserTest {

    private ChangeModeCommandParser parser = new ChangeModeCommandParser();

    @Test
    public void parseValidArgsReturnsChangeModeCommand() {
        assertParseSuccess(parser, "ab", new ChangeModeCommand("ab"));
    }

    @Test
    public void parseInvalidArgsThrowsParseException() {
        assertParseFailure(parser, "", String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeModeCommand
            .MESSAGE_USAGE));
    }
}
```
###### /java/seedu/address/logic/parser/FindTaskCommandParserTest.java
``` java
public class FindTaskCommandParserTest {

    private FindTaskCommandParser parser = new FindTaskCommandParser();

    @Test
    public void parseEmptyArgThrowsParseException() {
        assertParseFailure(parser, "     ",
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTaskCommand.MESSAGE_USAGE));
    }

    @Test
    public void parseValidArgsReturnsFindCommand() {
        // no leading and trailing whitespaces
        FindTaskCommand expectedTaskFindCommand =
            new FindTaskCommand(new TaskContainsKeywordsPredicate(Arrays.asList("Finish", "art")));
        assertParseSuccess(parser, "Finish art", expectedTaskFindCommand);

        // multiple whitespaces between keywords
        assertParseSuccess(parser, " \n Finish \n \t art  \t", expectedTaskFindCommand);
    }

}
```
###### /java/seedu/address/logic/parser/SelectTaskCommandParserTest.java
``` java
/**
 * Test scope: similar to {@code DeleteCommandParserTest}.
 * @see DeleteCommandParserTest
 */
public class SelectTaskCommandParserTest {

    private SelectTaskCommandParser parser = new SelectTaskCommandParser();

    @Test
    public void parseValidArgsReturnsSelectTaskCommand() {
        assertParseSuccess(parser, "1", new SelectTaskCommand(INDEX_FIRST_TASK));
    }

    @Test
    public void parseInvalidArgsThrowsParseException() {
        assertParseFailure(parser, "a", String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectTaskCommand.MESSAGE_USAGE));
    }
}
```
###### /java/seedu/address/model/CommandModeTest.java
``` java
public class CommandModeTest {

    @Test
    public void isValid() {
        //Invalid command modes
        assertFalse(CommandMode.isValidMode("")); //empty string
        assertFalse(CommandMode.isValidMode(" ")); //empty string with 1 white space
        assertFalse(CommandMode.isValidMode("abc123")); //wrong command mode
        assertFalse(CommandMode.isValidMode("ab 123")); //more than 1 word
        assertFalse(CommandMode.isValidMode("abtm")); //mixture of both command modes

        //Valid command modes
        assertTrue(CommandMode.isValidMode("ab")); //addressbook mode short form
        assertTrue(CommandMode.isValidMode("addressbook")); //addressbook mode
        assertTrue(CommandMode.isValidMode("AddReSsBoOk")); //mixed case addressbook mode
        assertTrue(CommandMode.isValidMode("tm")); //taskmanager mode
        assertTrue(CommandMode.isValidMode("taskmanager")); //taskmanager mode
        assertTrue(CommandMode.isValidMode("TaSkMaNaGeR")); //mixed case taskmanager mode
    }
}
```
###### /java/seedu/address/model/task/DescriptionTest.java
``` java
public class DescriptionTest {
    @Test
    public void isValid() {
        //invalid description
        assertFalse(Description.isValidDescription("")); //empty string
        assertFalse(Description.isValidDescription(" ")); //string with only whitespace
        assertFalse(Description.isValidDescription("???")); //string with only non-alphanumeric character
        assertFalse(Description.isValidDescription("/do this/")); //string containing non-alphanumeric character

        //valid description
        assertTrue(Description.isValidDescription("Self evaluation for class")); // only letters
        assertTrue(Description.isValidDescription("247")); // only numbers
        assertTrue(Description.isValidDescription("a")); // only 1 char
        assertTrue(Description.isValidDescription("DO NOT PROCRASTINATE")); // only capital letters
        assertTrue(Description.isValidDescription("finish the 2nd assignment")); // alphanumeric characters
        assertTrue(Description.isValidDescription("This is a long description and i am not sure "
            + "what to type now but i still need to continue typing")); // long description
    }
}
```
###### /java/seedu/address/TestApp.java
``` java
    /**
     * Returns a defensive copy of the model.
     */
    public Model getModel() {
        Model copy = new ModelManager((model.getAddressBook()), new UserPrefs());
        ModelHelper.setFilteredPersonsList(copy, model.getFilteredPersonList());
        ModelHelper.setFilteredTaskList(copy, model.getFilteredTaskList());
        return copy;
    }
```
###### /java/seedu/address/ui/TaskCardTest.java
``` java
public class TaskCardTest extends GuiUnitTest {

    @Test
    public void display() {
        Task task = new TaskBuilder().build();
        TaskCard taskCard = new TaskCard(task, 1);
        uiPartRule.setUiPart(taskCard);
        assertCardDisplay(taskCard, task, 1);

        // changes made to task reflects on card
        guiRobot.interact(() -> {
            task.setDescription(ASSIGNMENT.getDescription());
            task.setStartDate(ASSIGNMENT.getStartDate());
            task.setDeadline(ASSIGNMENT.getDeadline());
        });
        assertCardDisplay(taskCard, task, 1);
    }

    @Test
    public void equals() {
        Task task = new TaskBuilder().build();
        TaskCard taskCard = new TaskCard(task, 1);

        // same task, same index -> returns true
        TaskCard copy = new TaskCard(task, 1);
        assertTrue(taskCard.equals(copy));

        // same object -> returns true
        assertTrue(taskCard.equals(taskCard));

        // different types -> returns false
        assertFalse(taskCard.equals(0));

    }

    /**
     * Asserts that {@code taskCard} displays the details of {@code expectedtask} correctly and matches
     * {@code expectedId}.
     */
    private void assertCardDisplay(TaskCard taskCard, ReadOnlyTask expectedTask, int expectedId) {
        guiRobot.pauseForHuman();

        TaskCardHandle taskCardHandle = new TaskCardHandle(taskCard.getRoot());

        // verify id is displayed correctly
        assertEquals("  " + Integer.toString(expectedId) + ". ", taskCardHandle.getId());

        // verify task details are displayed correctly
        assertCardDisplaysTask(expectedTask, taskCardHandle);
    }
}
```
###### /java/seedu/address/ui/testutil/GuiTestAssert.java
``` java
    /**
     * Asserts that the list in {@code taskListPanelHandle} displays the details of {@code tasks} correctly and
     * in the correct order.
     */
    public static void assertTaskListMatching(TaskListPanelHandle taskListPanelHandle, ReadOnlyTask... tasks) {
        for (int i = 0; i < tasks.length; i++) {
            assertCardDisplaysTask(tasks[i], taskListPanelHandle.getTaskCardHandle(i));
        }
    }

    /**
     * Asserts that the list in {@code taskListPanelHandle} displays the details of {@code tasks} correctly and
     * in the correct order.
     */
    public static void assertTaskListMatching(TaskListPanelHandle taskListPanelHandle, List<ReadOnlyTask> tasks) {
        assertTaskListMatching(taskListPanelHandle, tasks.toArray(new ReadOnlyTask[0]));
    }
```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    public TaskListPanelHandle getTaskListPanel() {
        return mainWindowHandle.getTaskListPanel();
    }
```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    /**
     * Displays all tasks in the address book.
     */
    protected void showAllTasks() {
        executeCommand(ListCommand.COMMAND_WORD);
        executeCommand(ListTasksCommand.COMMAND_WORD);
        assert getModel().getAddressBook().getTaskList().size() == getModel().getFilteredTaskList().size();
    }
```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    /**
     * Displays all tasks with any parts of their description matching {@code keyword} (case-insensitive).
     */
    protected void showTasksWithDescription(String keyword) {
        executeCommand(FindTaskCommand.COMMAND_WORD + " " + keyword);
        assert getModel().getFilteredTaskList().size() < getModel().getAddressBook().getTaskList().size();
    }
```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    /**
     * Selects the task at {@code index} of the displayed list.
     */
    protected void selectTask(Index index) {
        executeCommand(SelectTaskCommand.COMMAND_WORD + " " + index.getOneBased());
        assert getTaskListPanel().getSelectedTaskCardIndex() == index.getZeroBased();
    }
```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    /**
     * Calls {@code BrowserPanelHandle}, {@code PersonListPanelHandle} and {@code StatusBarFooterHandle} to remember
     * their current state.
     */
    private void rememberStates() {
        StatusBarFooterHandle statusBarFooterHandle = getStatusBarFooter();
        getBrowserPanel().rememberUrl();
        statusBarFooterHandle.rememberSaveLocation();
        statusBarFooterHandle.rememberSyncStatus();
        getPersonListPanel().rememberSelectedPersonCard();
        getTaskListPanel().rememberSelectedTaskCard();
    }
```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    /**
     * Asserts that the previously selected card is now deselected
     */
    protected void assertSelectedTaskCardDeselected() {
        assertFalse(getTaskListPanel().isAnyCardSelected());
    }

    /**
     * Asserts that the task card selected is changed
     * {@code expectedSelectedTaskCardIndex}, and only the card at {@code expectedSelectedTaskCardIndex} is selected.
     * @see TaskListPanelHandle#isSelectedTaskCardChanged()
     */
    protected void assertSelectedTaskCardChanged(Index expectedSelectedTaskCardIndex) {
        assertEquals(expectedSelectedTaskCardIndex.getZeroBased(), getTaskListPanel().getSelectedTaskCardIndex());
    }

    /**
     * Asserts that the selected card in the task list panel remain unchanged.
     * @see TaskListPanelHandle#isSelectedTaskCardChanged()
     */
    protected void assertSelectedTaskCardUnchanged() {
        assertFalse(getTaskListPanel().isSelectedTaskCardChanged());
    }
```
###### /java/systemtests/FindTaskCommandSystemTest.java
``` java
    @Test
    public void find() {

        /* ----------------- Performing delete operation while an unfiltered list is being shown -------------------- */

        /*change the current command mode to task manager*/
        executeCommand(ChangeModeCommand.COMMAND_WORD + " tm");

        /* Case: find multiple tasks in address book, command with leading spaces and trailing spaces
         * -> 2 tasks found
         */
        String command = "   " + FindTaskCommand.COMMAND_WORD + " " + KEYWORD_MATCHING_FINISH + "   ";
        Model expectedModel = getModel();
        ModelHelper.setFilteredTaskList(expectedModel,
            ASSIGNMENT, PERSONAL_PROJECT); // first word of Assignment and Personal_project is "Finish".
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: repeat previous find command where task list is displaying the tasks we are finding
         * -> 2 tasks found
         */
        command = FindTaskCommand.COMMAND_WORD + " " + KEYWORD_MATCHING_FINISH;
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: mixed case command word -> 2 tasks found */
        command = "FiNd Finish";
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find task where task list is not displaying the task we are finding -> 1 task found */
        command = FindTaskCommand.COMMAND_WORD + " Gym";
        ModelHelper.setFilteredTaskList(expectedModel, GYM);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

```
###### /java/systemtests/FindTaskCommandSystemTest.java
``` java
        /* Case: find multiple tasks in address book, 2 keywords -> 2 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " enhancement art";
        ModelHelper.setFilteredTaskList(expectedModel, ASSIGNMENT, PERSONAL_PROJECT);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find multiple tasks in address book, 2 keywords in reversed order -> 2 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " art enhancement";
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find multiple tasks in address book, 2 keywords with 1 repeat -> 2 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " art enhancement art";
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find multiple tasks in address book, 2 matching keywords and 1 non-matching keyword
         * -> 2 tasks found
         */
        command = FindTaskCommand.COMMAND_WORD + " art enhancement NonMatchingKeyWord";
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: undo previous find command -> rejected */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_FAILURE;
        assertCommandFailure(command, expectedResultMessage);

        /* Case: redo previous find command -> rejected */
        command = RedoCommand.COMMAND_WORD;
        expectedResultMessage = RedoCommand.MESSAGE_FAILURE;
        assertCommandFailure(command, expectedResultMessage);

        /* Case: find same tasks in address book after deleting 1 of them -> 1 task found */
        executeCommand(DeleteTaskCommand.COMMAND_WORD + " 1");
        assert !getModel().getAddressBook().getTaskList().contains(ASSIGNMENT);
        command = FindTaskCommand.COMMAND_WORD + " " + KEYWORD_MATCHING_FINISH;
        expectedModel = getModel();
        ModelHelper.setFilteredTaskList(expectedModel, PERSONAL_PROJECT);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find task in address book, keyword is same as name but of different case -> 1 task found */
        command = FindTaskCommand.COMMAND_WORD + " FiNiSh";
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find task in address book, keyword is substring of name -> 0 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " fin";
        ModelHelper.setFilteredTaskList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find task in address book, name is substring of keyword -> 0 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " Finishes";
        ModelHelper.setFilteredTaskList(expectedModel);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find task not in address book -> 0 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " Handsome";
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

        /* Case: find start date of task in address book -> 0 tasks found */
        command = FindTaskCommand.COMMAND_WORD + " " + ASSIGNMENT.getStartDate().date;
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();
```
###### /java/systemtests/FindTaskCommandSystemTest.java
``` java
        /* Case: find while a task is selected -> selected card deselected */
        showAllTasks();
        selectTask(Index.fromOneBased(1));
        assert !getTaskListPanel().getHandleToSelectedCard()
            .getDescription().equals(BUY_TICKETS.getDescription().taskDescription);
        command = FindTaskCommand.COMMAND_WORD + " art";
        ModelHelper.setFilteredTaskList(expectedModel, PERSONAL_PROJECT);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardDeselected();

        /* Case: find task in empty address book -> 0 tasks found */
        executeCommand(ClearCommand.COMMAND_WORD);
        assert getModel().getAddressBook().getTaskList().size() == 0;
        command = FindTaskCommand.COMMAND_WORD + " " + KEYWORD_MATCHING_FINISH;
        expectedModel = getModel();
        ModelHelper.setFilteredTaskList(expectedModel, PERSONAL_PROJECT);
        assertCommandSuccess(command, expectedModel);
        assertSelectedTaskCardUnchanged();

    }

    /**
     * Executes {@code command} and verifies that the command box displays an empty string, the result display
     * box displays {@code Messages#MESSAGE_PERSONS_LISTED_OVERVIEW} with the number of people in the filtered list,
     * and the model related components equal to {@code expectedModel}.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the status bar remains unchanged, and the command box has the default style class, and the
     * selected card updated accordingly, depending on {@code cardStatus}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel) {
        String expectedResultMessage = String.format(
            MESSAGE_TASK_LISTED_OVERVIEW, expectedModel.getFilteredTaskList().size());

        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchanged();
    }

    /**
     * Executes {@code command} and verifies that the command box displays {@code command}, the result display
     * box displays {@code expectedResultMessage} and the model related components equal to the current model.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the browser url, selected card and status bar remain unchanged, and the command box has the
     * error style.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedTaskCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }

}
```
###### /java/systemtests/ModelHelper.java
``` java
    /**
     * Updates {@code model}'s filtered list to display only {@code tasksToDisplay}.
     */
    public static void setFilteredTasksList(Model model, List<ReadOnlyTask> tasksToDisplay) {
        Optional<Predicate<ReadOnlyTask>> predicateTasks =
                tasksToDisplay.stream().map(ModelHelper::getPredicateTaskMatching).reduce(Predicate::or);
        model.updateFilteredTaskList(predicateTasks.orElse(PREDICATE_MATCHING_NO_TASKS));
    }

    /**
     * @see ModelHelper#setFilteredPersonsList(Model, List)
     */
    public static void setFilteredTasksList(Model model, ReadOnlyTask... tasksToDisplay) {
        setFilteredTasksList(model, Arrays.asList(tasksToDisplay));
    }

    /**
     * Update {@code model}'s filtered task list to display only {@code tasksToDisplay}.
     */
    public static void setFilteredTaskList(Model model, List<ReadOnlyTask> tasksToDisplay) {
        Optional<Predicate<ReadOnlyTask>> predicate =
            tasksToDisplay.stream().map(ModelHelper::getPredicateTaskMatching).reduce(Predicate::or);
        model.updateFilteredTaskList(predicate.orElse(PREDICATE_MATCHING_NO_TASKS));
    }

    /**
     * @see ModelHelper#setFilteredTaskList(Model, List)
     */
    public static void setFilteredTaskList(Model model, ReadOnlyTask... toDisplay) {
        setFilteredTaskList(model, Arrays.asList(toDisplay));
    }
```
###### /java/systemtests/ModelHelper.java
``` java
    /**
     * Returns a predicate that evaluates to true if this {@code ReadOnlyTask} equals to {@code other}.
     */
    private static Predicate<ReadOnlyTask> getPredicateTaskMatching(ReadOnlyTask other) {
        return task -> task.equals(other);
    }
```
###### /java/systemtests/SelectTaskCommandSystemTest.java
``` java
public class SelectTaskCommandSystemTest extends AddressBookSystemTest {
    @Test
    public void select() {

        /*change the current command mode to task manager*/
        executeCommand(ChangeModeCommand.COMMAND_WORD + " tm");

        /* Case: select the first card in the task list, command with leading spaces and trailing spaces
         * -> selected
         */
        String command = "   " + SelectTaskCommand.COMMAND_WORD + " " + INDEX_FIRST_TASK.getOneBased() + "   ";
        assertCommandSuccess(command, INDEX_FIRST_TASK);

        /* Case: select the last card in the person list -> selected */
        Index personCount = Index.fromOneBased(getTypicalTasks().size());
        command = SelectTaskCommand.COMMAND_WORD + " " + personCount.getOneBased();
        assertCommandSuccess(command, personCount);

        /* Case: mixed case command word -> selected */
        assertCommandSuccess("SeLeCt 1", INDEX_FIRST_TASK);

        /* Case: undo previous selection -> rejected */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_FAILURE;
        assertCommandFailure(command, expectedResultMessage);

        /* Case: redo selecting last card in the list -> rejected */
        command = RedoCommand.COMMAND_WORD;
        expectedResultMessage = RedoCommand.MESSAGE_FAILURE;
        assertCommandFailure(command, expectedResultMessage);

        /* Case: select the middle card in the person list -> selected */
        Index middleIndex = Index.fromOneBased(personCount.getOneBased() / 2);
        command = SelectTaskCommand.COMMAND_WORD + " " + middleIndex.getOneBased();
        assertCommandSuccess(command, middleIndex);

        /* Case: invalid index (size + 1) -> rejected */
        int invalidIndex = getModel().getFilteredTaskList().size() + 1;
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " " + invalidIndex, MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        /* Case: select the current selected card -> selected */
        assertCommandSuccess(command, middleIndex);

        /* Case: filtered person list, select index within bounds of address book but out of bounds of person list
         * -> rejected
         */
        showTasksWithDescription(GYM.getDescription().taskDescription);
        invalidIndex = getModel().getAddressBook().getTaskList().size();
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " " + invalidIndex, MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        /* Case: filtered person list, select index within bounds of address book and person list -> selected */
        Index validIndex = Index.fromOneBased(1);
        assert validIndex.getZeroBased() < getModel().getFilteredTaskList().size();
        command = SelectTaskCommand.COMMAND_WORD + " " + validIndex.getOneBased();
        assertCommandSuccess(command, validIndex);

        /* Case: invalid index (0) -> rejected */
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " " + 0,

            String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectTaskCommand.MESSAGE_USAGE));

        /* Case: invalid index (-1) -> rejected */
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " " + -1,
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectTaskCommand.MESSAGE_USAGE));

        /* Case: invalid arguments (alphabets) -> rejected */
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " abc",
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectTaskCommand.MESSAGE_USAGE));

        /* Case: invalid arguments (extra argument) -> rejected */
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " 1 abc",
            String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectTaskCommand.MESSAGE_USAGE));

        /* Case: select from empty address book -> rejected */
        executeCommand(ClearCommand.COMMAND_WORD);
        assert getModel().getAddressBook().getTaskList().size() == 0;
        assertCommandFailure(SelectTaskCommand.COMMAND_WORD + " " + INDEX_FIRST_TASK.getOneBased(),
            MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    /**
     * Executes {@code command} and verifies that the command box displays an empty string, the result display
     * box displays the success message of executing select command with the {@code expectedSelectedCardIndex}
     * of the selected person, and the model related components equal to the current model.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the command box has the default style class and the status bar remain unchanged. The resulting
     * browser url and selected card will be verified if the current selected card and the card at
     * {@code expectedSelectedCardIndex} are different.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     * @see AddressBookSystemTest#assertSelectedTaskCardChanged(Index)
     */
    private void assertCommandSuccess(String command, Index expectedSelectedCardIndex) {
        Model expectedModel = getModel();
        String expectedResultMessage = String.format(
            MESSAGE_SELECT_TASK_SUCCESS, expectedSelectedCardIndex.getOneBased());
        int preExecutionSelectedCardIndex = getTaskListPanel().getSelectedTaskCardIndex();

        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);

        if (preExecutionSelectedCardIndex == expectedSelectedCardIndex.getZeroBased()) {
            assertSelectedTaskCardUnchanged();
        } else {
            assertSelectedTaskCardChanged(expectedSelectedCardIndex);
        }

        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchanged();
    }

    /**
     * Executes {@code command} and verifies that the command box displays {@code command}, the result display
     * box displays {@code expectedResultMessage} and the model related components equal to the current model.
     * These verifications are done by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * Also verifies that the browser url, selected card and status bar remain unchanged, and the command box has the
     * error style.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedTaskCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
